\chapter{扩展立方体的结构连通度和子结构连通度}
\label{Chap03}
在这一章中，我们研究了扩展立方体的$H$-结构连通度和$H$-子结构连通度，其中$H \in \{K_{1,M}，P_L,C_N\},1 \leq M \leq 6, 1 \leq L \leq 2n-1, 3 \leq N \leq 2n-1$。设$u$ 是$AQ_n$中的任意一个顶点。为了使我们的证明更加的简便和简洁，我们引入了一些符号$v^{[1]},v^{[2]},\ldots,v^{[2n-1]}$，其中$ v^{[1]},v^{[2]},\ldots,v^{[2n-1]}$和$u$的所有邻居节点$u^1,u^2,\bar{u}^{2},\ldots,u^{n},\bar{u}^{n}$形成一一对应的关系。$u^j$和 $v^{[i]}$ 的对应关系为：（1）如果$i$是偶数，则$j=\frac{i}{2}+1$和$u^j=v^{[i]}$；（2）如果$i$是奇数，则$j=\lfloor\frac{i}{2}\rfloor+1$和$\bar{u}^j=v^{[i]}$。$(v^{[i]})^l$ 和$(\overline{v^{[i]}})^l$的定义类似于$u^l$和$\bar{u}^l$的定义。例如，如果$u=000000$ 是$AQ_6$的一个顶点，那么$u^4=v^{[6]}=001000$,  $\bar{u}^5=v^{[9]}=011111, (v^{[6]})^2=001010$和$(\overline{v^{[9]}})^3=011000$。在这篇文章中，我们对这两种表示方法不加以区分。

\section{$\kappa(AQ_n,K_{1,M})$ \textnormal{和} $\kappa^s(AQ_n,K_{1,M})$}


根据扩展立方体的定义，性质\ref{hypercube_edge}和性质\ref{complement_edge}，如果$u$是$AQ_n$ 的任意一个顶点且$(u,\bar{u}^i)$是$AQ_n$的$i(2\leq i \leq n-1)$维的补边，那么$N_{AQ_n}(u)\cap N_{AQ_n}(\bar{u}^i)=\{\bar{u}^{i-1},u^i,u^{i+1},\bar{u}^{i+1}\}$。$\{\bar{u}^i,\bar{u}^{i-1},u^i,u^{i+1}, \bar{u}^{i+1}\}$ $(2\leq i \leq n-1)$的导出子图与$K_{1,4}$同构。如果$(u,\bar{u}^n)$是$AQ_n$的$n$维的补边，那么$N_{AQ_n}(u)\cap N_{AQ_n}(\bar{u}^n)=\{\bar{u}^{n-1},u^n\}$ 且$\{\bar{u}^n,\bar{u}^{n-1},u^n\}$的生成子图与$K_{1,2}$同构。类似的，如果$(u,u^i)$是$AQ_n$ 的$i$ $(1\leq i \leq n)$维的超立方体边，那么$N_{AQ_n}(u)\cap N_{AQ_n}(u^i)=\{\bar{u}^{i},\bar{u}^{i-1}\}(2\leq i \leq n)$和$N_{AQ_n}(u)\cap N_{AQ_n}(u^1)=\{u^{2},\bar{u}^{2}\}$。$\{u^i,\bar{u}^i$,$\bar{u}^{i-1}\}(2\leq i \leq n)$ 的导出子图与$K_{1,2}$同构。

接下来，我们将讨论$\kappa(AQ_n,K_{1,M})$和$\kappa^s(AQ_n,K_{1,M})$，其中$1 \leq M \leq 3,4 \leq M \leq 6$。

\subsection{$1 \leq M \leq 3$}

\begin{lem}
\label{1<=M<=3(1)}
对于$n \geq 4$和$1 \leq M \leq 3$, $\kappa(AQ_n,K_{1,M})$ $\leq$ $\lceil\frac{2n-1}{1+M}\rceil$和$\kappa^s(AQ_n,K_{1,M})$ $\leq$ $\lceil\frac{2n-1}{1+M}\rceil$.
\end{lem}

\begin{proof}
设$u$是$AQ_n$的任意一个顶点，接下来，我们将根据$M$和$n$的值来分为下面几种情况：

情形1. $M=1$. 设
\begin{flushleft}
$S_1=\{
\{
v^{[(M+1)i+1]},
v^{[(M+1)i+2]}
\}
\mid 0 \leq i < \lfloor\frac{2n-1}{M+1}\rfloor\}$ and
$S_2=\{\{
v^{[2n-1]},
(v^{[2n-1]})^1
\}\}$.

\end{flushleft}

情形2. $M=2$.

情形2.1. $n\equiv0$(mod 3). 设
\begin{flushleft}
$S_1=\{\{
v^{[(M+1)i+1]},
v^{[(M+1)i+2]},
v^{[(M+1)i+3]}
\}
\mid 0 \leq i < \lfloor\frac{2n-1}{M+1}\rfloor\}$.

\end{flushleft}

情形2.2. $n\equiv1$(mod 3). 设
\begin{flushleft}
$S_1=\{\{
v^{[(M+1)i+1]},
v^{[(M+1)i+2]},
v^{[(M+1)i+3]}
\}
\mid 0 \leq i < \lfloor\frac{2n-1}{M+1}\rfloor\}$
and $S_2=\{\{
v^{[2n-1]},
(v^{[2n-1]})^1,
(v^{[2n-1]})^2
\}\}$.

\end{flushleft}

情形2.3. $n\equiv2$(mod 3). 设
\begin{flushleft}
$S_1=\{\{
v^{[(M+1)i+1]},
v^{[(M+1)i+2]},
v^{[(M+1)i+3]}
\}
\mid 0 \leq i < \lfloor\frac{2n-1}{M+1}\rfloor\}$
and
$S_2=\{\{
v^{[2n-2]},
v^{[2n-1]},
(v^{[2n-1]})^1
\}\}$.

\end{flushleft}

情形3. $M=3$.

情形3.1. $n\equiv1$(mod 4). 设
\begin{flushleft}
$S_1=\{\{
v^{[(M+1)i+1]},
v^{[(M+1)i+2]},
v^{[(M+1)i+3]},
v^{[(M+1)i+4]}
\}
\mid 0 \leq i < \lfloor\frac{2n-1}{M+1}\rfloor\}$
and
$S_2=\{\{
v^{[2n-1]},
(v^{[2n-1]})^1,
(v^{[2n-1]})^2,
(v^{[2n-1]})^3
\}\}$.

\end{flushleft}

情形3.2. $n\equiv3$(mod 4). 设
\begin{flushleft}
$S_1=\{\{
v^{[(M+1)i+1]},
v^{[(M+1)i+2]},
v^{[(M+1)i+3]},
v^{[(M+1)i+4]}
\}
\mid 0 \leq i < \lfloor\frac{2n-1}{M+1}\rfloor\}$
and
$S_2=\{\{
v^{[2n-3]},
v^{[2n-2]},
v^{[2n-1]},
(v^{[2n-1]})^1
\}\}$.

\end{flushleft}

当$M = 2,n \equiv 0(mod 3)$时，设$S=S_1$或者$(S=S_1 \cup S_2)$。显然，如果$M=1$，$S_1 \cup S_2$中的每个元素的导出子图和$K_{1,1}$同构；如果$M=2$，顶点$v^{[(M+1)i+2]}$邻接于顶点$v^{[(M+1)i+1]}$和$v^{[(M+1)i+3]},0 \leq i < \lfloor\frac{2n-1}{M+1}\rfloor$，顶点$v^{[2n-1]}$邻接于$v^{[2n-2]}$, $(v^{[2n-1]})^1$，和 $(v^{[2n-1]})^2$。因此，$S$中的每个元素的导出子图和$K_{1,2}$同构；如果$M=3$，顶点$v^{[(M+1)i+3]}$邻接于顶点$v^{[(M+1)i+1]}$, $v^{[(M+1)i+2]}$，和$v^{[(M+1)i+4]},0 \leq i < \lfloor\frac{2n-1}{M+1}\rfloor$，顶点$v^{[2n-1]}$邻接于$v^{[2n-3]}, v^{[2n-2]},(v^{[2n-1]})^1$, $(v^{[2n-1]})^2$，和 $(v^{[2n-1]})^3$。这样，$S$中每个元素的导出子图和$K_{1,3}$同构。显然，$|S|$ = $\lceil\frac{2n-1}{1+M}\rceil$。设$W(S)=\cup_{f \in S}f$，因为$AQ_n-W(S)$是不连通的且其中一个连通分量是\{$u$\}，所以$\kappa(AQ_n,K_{1,M})$ $\leq$ $\lceil\frac{2n-1}{1+M}\rceil$和$\kappa^s(AQ_n,K_{1,M})$ $\leq$ $\lceil\frac{2n-1}{1+M}\rceil$。
\end{proof}

图~\ref{K_1_1 and K_1_2}显示了$AQ_6$的$K_{1,1}$-结构割和$K_{1,2}$-结构割。


\begin{figure}[htbp]
    \centering
    \subfigure[A $K_{1,1}$-structure-cut in $AQ_5$]{
    \begin{minipage}{8cm}
    \centering
        \includegraphics[scale=0.3]{K_1_1.eps}
    \end{minipage}
    }
    \subfigure[A $K_{1,2}$-structure-cut in $AQ_6$]{
    \begin{minipage}{8cm}
    \centering
        \includegraphics[scale=0.3]{K_1_2.eps}
    \end{minipage}
    }
    \caption{A $K_{1,1}$-structure-cut in $AQ_5$ and a $K_{1,2}$-structure-cut in $AQ_6$}
    \label{K_1_1 and K_1_2}
\end{figure}




\begin{lem}
\label{1<=M<=3(2)}
对于$n\geq4$和$1 \leq M \leq 3$, $\kappa^s(AQ_n,K_{1,M})$ $\geq$ $\lceil\frac{2n-1}{1+M}\rceil$。
\end{lem}

\begin{proof}
设$F_n^*$是$AQ_n$中的一个连通子图的集合，这个集合中的每个元素都同构于$K_{1,M}$且$|F_n^*|\leq \lceil\frac{2n-1}{1+M}\rceil-1$。因此$|V(F_n^*)|\leq (1+M)\times(\lceil\frac{2n-1}{1+M}\rceil-1)< 2n-1$。因为$\kappa(AQ_n)= 2n-1$, $AQ_n-F_n^*$ 是连通的。因此引理成立。
\end{proof}

因为$\kappa(Q_n,K_{1,M})\geq \kappa^s(Q_n,K_{1,M})$,  $\kappa(Q_n,K_{1,M})\geq \lceil\frac{2n-1}{1+M}\rceil$。根据引理\ref{1<=M<=3(1)}和引理\ref{1<=M<=3(2)}，我们有下面的定理。




\begin{thm}
\label{smallerthan}
对于$n \geq 4$和$1 \leq M \leq 3$, $\kappa(AQ_n,K_{1,M})=\lceil\frac{2n-1}{1+M}\rceil$，$\kappa^s(AQ_n,K_{1,M})=\lceil\frac{2n-1}{1+M}\rceil$。
\end{thm}


\subsection{$4 \leq M \leq 6$}

\begin{lem}
\label{4<=M<=6(1)}
对于$n \geq 6$和$4 \leq M \leq 6$, $\kappa(AQ_n,K_{1,M})$ $\leq$ $\lceil\frac{n-1}{2}\rceil$，$\kappa^s(AQ_n,K_{1,M})$ $\leq$ $\lceil\frac{n-1}{2}\rceil$。
\end{lem}

\begin{proof}
设$u$是$AQ_n$中的任意一个顶点。接下来，我们将根据$M$和$n$的值有下面几种情况：

情形1. $M=4$.

情形1.1. $n$是奇数，设

\begin{flushleft}
$S_1=\{\{v^{[1]},v^{[2]},v^{[3]},v^{[4]},v^{[5]}\}\}$ 和

$S_2=\{\{
v^{[5+4i+1]},
v^{[5+4i+2]},
v^{[5+4i+3]},
v^{[5+4i+4]},
(v^{[5+4i+2]})^1
\} \mid 0\leq i< \lfloor\frac{n-1}{2}\rfloor-1 $\}.

\end{flushleft}

情形1.2. $n$是偶数，设

\begin{flushleft}
$S_1=\{\{v^{[1]},v^{[2]},v^{[3]},v^{[4]},v^{[5]}\}\}$,

$S_2=\{\{
v^{[5+4i+1]},
v^{[5+4i+2]},
v^{[5+4i+3]},
v^{[5+4i+4]},
(v^{[5+4i+2]})^1
\} \mid 0\leq i< \lfloor\frac{n-1}{2}\rfloor-1 $\}, 和\\

$S_3=\{\{
v^{[2n-2]},
v^{[2n-1]},
(v^{[2n-1]})^1,
(v^{[2n-1]})^2,
(v^{[2n-1]})^3
\}$\}.\\

\end{flushleft}


情形2. $M=5$.

情形2.1. $n$是奇数. 设

\begin{flushleft}
$S_1=\{\{v^{[1]},v^{[2]},v^{[3]},v^{[4]},v^{[5]},(v^{[3]})^n\}\}$ 和

$S_2=\{\{
v^{[5+4i+1]},
v^{[5+4i+2]},
v^{[5+4i+3]},
v^{[5+4i+4]},
(v^{[5+4i+2]})^1,
(v^{[5+4i+2]})^2
\} \mid 0\leq i< \lfloor\frac{n-1}{2}\rfloor-1 $\}.

\end{flushleft}

情形2.2. $n$是偶数. 设

\begin{flushleft}
$S_1=\{\{v^{[1]},v^{[2]},v^{[3]},v^{[4]},v^{[5]},(v^{[3]})^n\}\}$,

$S_2=\{\{
v^{[5+4i+1]},
v^{[5+4i+2]},
v^{[5+4i+3]},
v^{[5+4i+4]},
(v^{[5+4i+2]})^1,
(v^{[5+4i+2]})^2
\} \mid 0\leq i< \lfloor\frac{n-1}{2}\rfloor-1 $\}, 和\\

$S_3=\{\{
v^{[2n-2]},
v^{[2n-1]},
(v^{[2n-1]})^1,
(v^{[2n-1]})^2,
(v^{[2n-1]})^3,
(v^{[2n-1]})^4
\}$\}.\\

\end{flushleft}

情形3. $M=6$.

情形3.1. $n$是奇数. 设

\begin{flushleft}
$S_1=\{\{v^{[1]},v^{[2]},v^{[3]},v^{[4]},v^{[5]},(v^{[3]})^n,(\overline{v^{[3]}})^n\}\}$ 和

$S_2=\{\{
v^{[5+4i+1]},
v^{[5+4i+2]},
v^{[5+4i+3]},
v^{[5+4i+4]},
(v^{[5+4i+2]})^1,
(v^{[5+4i+2]})^2,
(v^{[5+4i+2]})^3
\} \mid 0\leq i< \lfloor\frac{n-1}{2}\rfloor-1 $\}.

\end{flushleft}

情形3.2. $n$是偶数. 设

\begin{flushleft}
$S_1=\{\{v^{[1]},v^{[2]},v^{[3]},v^{[4]},v^{[5]},(v^{[3]})^n,(\overline{v^{[3]}})^n\}\}$,

$S_2=\{\{
v^{[5+4i+1]},
v^{[5+4i+2]},
v^{[5+4i+3]},
v^{[5+4i+4]},
(v^{[5+4i+2]})^1,
(v^{[5+4i+2]})^2,
(v^{[5+4i+2]})^3
\} \mid 0\leq i< \lfloor\frac{n-1}{2}\rfloor-1 $\}, 和\\

$S_3=\{\{
v^{[2n-2]},
v^{[2n-1]},
(v^{[2n-1]})^1,
(v^{[2n-1]})^2,
(v^{[2n-1]})^3,
(v^{[2n-1]})^4,
(v^{[2n-1]})^5
\}$\}.\\

\end{flushleft}


显然，$S_1$中的每个元素的导出子图和$K_{1,M}$同构。对于$0\leq i< \lfloor\frac{n-1}{2}\rfloor-1$, 顶点$v^{[5+4i+2]}$邻接于顶点$v^{[{5+4i}+j]}j=1,3,4$ 和$(v^{[5+4i+2]})^p,1\leq p \leq 1+M-4$。这样，$S_2$中的每个元素的导出子图和$K_{1,M}$ 同构。顶点$v^{[2n-1]}$邻接于顶点$v^{[2n-2]},(v^{([2n-1]})^q,1\leq q\leq 1+M-(2n-2-4\times\lfloor\frac{n-1}{2}\rfloor)$。这样，$S_3$中的每个元素的导出子图和$K_{1,M}$。假设当$n$时奇数时，$S=S_1\cup S_2$（否则，$S=S_1\cup S_2\cup S_3$），并且$|S|=\lceil\frac{n-1}{2}\rceil$。设$W(S)=\cup_{f \in S}f$。因为$AQ_n - W(S)$是不连通的且它的一个连通分量是$\{u\}$，那么$\kappa(AQ_n,K_{1,M})$ $\leq$ $\lceil\frac{n-1}{2}\rceil$和$\kappa^s(AQ_n,K_{1,M})$ $\leq$ $\lceil\frac{n-1}{2}\rceil,4 \leq M \leq 6$。
\end{proof}

图~\ref{K_1_5}显示了$AQ_6$的一个$K_{1,5}$-结构割。

\begin{figure}
  \centering
  % Requires \usepackage{graphicx}
  \includegraphics[scale=0.3]{K_1_5.eps}\\
  \caption{A $K_{1,5}$-structure-cut in $AQ_6$}
  \label{K_1_5}
\end{figure}

\begin{lem}
\label{min_K_1_M}
设$F_n$是$AQ_n$中的一个$K_{1,M}$-子结构集，其中$n \geq 6,4 \leq M \leq 6$. 如果在$AQ_n - V(F_n)$存在一个孤立的顶点，那么$|F_n|\geq \lceil\frac{n-1}{2}\rceil$。
\end{lem}

\begin{proof}
设$u$是$AQ_n$中的任意一个顶点。
我们设$W=\{x \mid (x,u)$是一条超立方体边，$x \in V(G)\}$和$Z=\{y \mid (y,u)$是一条补边，$y \in V(G)\}$。显然，$|W|=n,|Z|=n-1$。根据性质\ref{complement_edge}和性质\ref{common_verticles}，$F_n$中的每个元素最多包含$N(u)$中的$5$个顶点，及, $\bar{u}^i,\bar{u}^{i-1},u^i,u^{i+1}$，和$\bar{u}^{i+1},2 \leq i \leq n-1$。因为 $\{(\bar{u}^i,\bar{u}^{i-1}),(\bar{u}^i,u^i),(\bar{u}^i,u^{i+1}),(\bar{u}^i,\bar{u}^{i+1})\} \subseteq E(AQ_n)$， $\{\bar{u}^i,\bar{u}^{i-1},u^i,u^{i+1},\bar{u}^{i+1}\}$的导出子图和$K_{1,4}$同构。我们设$B=\{b_i\mid b_i\in F_n \textnormal{和} \{\bar{u}^{i-1},u^i,\bar{u}^i,u^{i+1},\bar{u}^{i+1}\} \subseteq V(b_i)\cap N(u)\}$。 因为每个$V(b_i)$包含$Z$中的$3$个顶点和$W$中的$2$个顶点，那么 $|B|<\lfloor\frac{2n-1}{5}\rfloor$。
接下来，我们将根据$|B|$的值来划分下面几种情况：

情形1. \quad $|B|=0$. 因为$F_n$中的每个元素包含$N(u)$中最多$4$个顶点，那么$|F_n| \geq \lceil \frac{2n-1}{4} \rceil$。

情形2. \quad $|B|=1$. 假设$\{\bar{u}^{i-1},u^i,\bar{u}^i,u^{i+1},\bar{u}^{i+1}\} \subseteq V(b_i),2 \leq i \leq n-1$. 因为$F_n-B$中的每个元素包含$N(u)-V(B)$中最多$4$ 个顶点，$|F_n| \geq 1+\lceil \frac{2n-6}{4} \rceil=\lceil \frac{n-1}{2} \rceil$。

情形3. \quad $|B|=2$. 假设$\{\bar{u}^{i-1},u^i,\bar{u}^i,u^{i+1},\bar{u}^{i+1}\} \subseteq V(b_i),
\{\bar{u}^{j-1},u^j,\bar{u}^j,u^{j+1},\bar{u}^{j+1}\} \subseteq V(b_j),2 \leq i,j \leq n-1$，和$|i-j|\geq 3$。 不失一般性，我们设$j>i$。

情形3.1. $j-i=3$.
那么$\{\bar{u}^{j-1},u^j,\bar{u}^j,u^{j+1},\bar{u}^{j+1}\}= \{\bar{u}^{i+2},u^{i+3},\bar{u}^{i+3},u^{i+4},\bar{u}^{i+4}\}$。
假设$w_1,w_2 \in N(u)-V(B)-\{u^{i+2}\}$且$w_1 \neq w_2$. By Properties \ref{two_hypercube_edges}, \ref{two_complement_edges} and \ref{hypercube_edge_and_complement_edge}, $N(u^{i+2}) \cap N(w_1) \cap N(w_2)=\emptyset$.
%then $u^{i+2}$ can't be a pendent vertex of $K_{1,m}$ with $m>2$ and $|V(K_{1,m})| \subseteq N(AQ_n)$.
In addition, vertex $u^{i+2}$ is not adjacent to the vertices in $N(u)-V(B)$.
%then $u^{i+2}$ can't be a center vertex of $K_{1,m}$ with $m
%  \geq 1$ and $|V(K_{1,m})| \subseteq N(AQ_n)$.
Therefore, there is an element $a \in F_n-B$ such that $u^{i+2} \in V(a)$ and $V(a) \cap \{N(u)-V(B)\} \leq 2$. Since each element in $F_n-B-\{a\}$ contains at most four distinct vertices in $N(u)-V(B)-V(a)$, $|F_n| \geq 2+1+\lceil\frac{2n-13}{4}\rceil=\lceil\frac{2n-1}{4}\rceil$.
\end{proof}


\section{广义超立方体的$1$-限制连通度下的容错路由}

在本小节中， 我们首先构建出当广义超立方体的故障顶点数小于其$1$-限制连通度
且每个无故障顶点都至少有一个无故障邻居时，
$G(m_{r},m_{r-1},\ldots,m_{1})$中任意两个无故障顶点之间的一条无故障路径的
容错路由算法GHCFP。然后，我们分析并证明该算法的时间复杂度。

我们给出的GHCFP算法中引用了Guo等人的算法BuildPathSet\upcite{Guo2009BCube}。
其算法可以构建出$G$中任意两个顶点$u$和$v$之间的$\kappa(G)$条不相交路径，
其中最短的路径长度为$dist(u,v)$，最长的路径长度为$dist(u,v)+2$，
且该算法的时间复杂度为$O(\kappa(G)^2)$。
接下来，在给出GHCFP之前，我们先给出BuildPathSet。

\subsection{$1$-限制连通度条件下的容错路由算法}
%\algnewcommand\AND{\textbf{and~}}
%\algnewcommand\OR{\textbf{or~}}
\begin{breakablealgorithm}
\small
\label{alg:buildPathSet}
    \caption{BuildPathSet($G(m_{r},m_{r-1},\ldots,m_{1}),u,v$)}
\begin{algorithmic}[1]
    \Require
    $G(m_{r},m_{r-1},\ldots,m_{1})$中两个不同的顶点$u=u_{r}u_{r-1}\dots u_{1}$和$v=v_{r}v_{r-1}\dots v_{1}$
    \Ensure  $G(m_{r},m_{r-1},\ldots,m_{1})$中以$u$为起点且以$v$为终点的$\sum^{r}_{i=1}(m_i - 1)$条路径。
    \Function{BuildPathSet}{$G(m_{r},m_{r-1},\ldots,m_{1}),u,v$} %\BuildPathSet
        \State PathSet$\gets \emptyset$;
        \For{$i=k$\;to\;$0$}
            \If{$u_i \neq v_i$}
                \State $P_i = DCRouting(u,v,i)$;
            \Else
                \State $c =$ a neighbor of $u$ at level $i$;
                \State $P_i = AltDCRouting(u,v,i,c)$;
            \EndIf
            \State add $P_i$ to PathSet;
        \EndFor
        \State \Return PathSet;
    \EndFunction%

    \Function{DCRouting}{$u,v,i$} %DCRouting
        \State $m = k$;
        \For{$j=i$\;to\;$i-k$}
            \State $\prod[m] = j$ mod $(k+1)$; \;/*$\prod$ is a permutation of $[k,k-1,\dots,1,0]$*/
            \State $m = m - 1$;
        \EndFor
        \State \Return $BCubeRouting(u,v,\prod)$;
    \EndFunction%

    \Function{AltDCRouting}{$u,v,i,c$} %DCRouting
        \State $path \gets \emptyset$;
        \State add $u$ to $path$;
        \State $m = k$;
        \For{$j=i-1$\;to\;$i-1-k$}
            \State $\prod[m] = j$ mod $(k+1)$;
            \State $m = m - 1$;
        \EndFor
        \State $path += BCubeRouting(c,v,\prod)$;
        \State \Return $path$;
    \EndFunction%

    \Function{BCubeRouting}{$u,v,\prod$} %\BuildPathSet
        \State $path \gets \emptyset$;
        \State add $u$ to $path$;
        \State $Node \gets u$;
        \For{$i=k$\;to\;$0$}
            \If{$u_{\prod[i]} \neq v_{\prod[i]}$}
                \State $Node_{\prod[i]} = v_{\prod[i]}$;
                \State append $Node$ to $path$;
            \EndIf
        \EndFor
        \State \Return $path$;
    \EndFunction%
\end{algorithmic}
\end{breakablealgorithm}

接下来，我们给出容错路由算法GHCFP。
该算法可以给出$G-F$中，
任意两个无故障顶点$u$和$v$之间的一条无故障路径，
其中$F$为$G$中的故障顶点集合，$|F|<\kappa^1(G)$，
且$G-F$中任意一个顶点都至少有一个邻居。


\algnewcommand\AND{\textbf{and~}}
\algnewcommand\OR{\textbf{or~}}

\begin{breakablealgorithm}
\small
\label{alg:ghcfp}
    \caption{GHCFP($r,u,v,F,G(m_{r},m_{r-1},\ldots,m_{1})$)}
\begin{algorithmic}[1]
    \Require
    $r$-维广义超立方体$G(m_{r},m_{r-1},\ldots,m_{1})$，
    一个故障顶点集合$F \subset V(G)$，
    两个不同的无故障顶点$u=u_{r}u_{r-1}\dots u_{1}$
    和$v=v_{r}v_{r-1}\dots v_{1}$。
    \Ensure  $G(m_{r},m_{r-1},\ldots,m_{1})-F$中一条从$u$到$v$的无故障路径。
    \Function{GHCFP}{$r,u,v,F,G(m_{r},m_{r-1},\ldots,m_{1})$} %\GHCHP
    \State $G \gets G(m_{r},m_{-1},\ldots,m_{1})$;
    \If{$F= \emptyset $}  \ \Return GHCP$(u,v,G,F)$;
    \ElsIf{$(u,v)\in E(G)$}   \ \Return ($u,v$);
    \EndIf
    \State $n \gets \max\{m_{1},m_{2},\ldots, m_{r}\}$;
    \State $k_1 \gets \sum^{r}_{i=0}(m_{i}-1)$, $k_2 \gets \sum^{r-1}_{i=0}(m_{i}-1)$, $\alpha \gets u_{r}$, $\beta \gets v_{r}$;
    \State $F_{\alpha} \gets F \cap V(G^{r}[\alpha])$, $F_{\beta} \gets F \cap V(G^{r}[\beta])$;
    \If{$ \alpha \neq \beta $}
        \If {$|F_{\alpha}|\geq k_2$}
            \State $P_1 \gets $PATHSEQ$(u, F, G^r[\alpha],G - V(G^{r}[\alpha]))$;
            \State 令$z$为$P_1$的最后一个顶点;
            \If{$z=v$} \ \Return $P_1$;
            \EndIf
            \State \ \Return ($P_1$, GHCP$(z,v,G - V(G^{r}[\alpha]),F\setminus F_{\alpha})$);
        \ElsIf{$|F_{\beta}|\geq k_2$}
            \State $P_1 \gets $PATHSEQ$(v, F, G^r[\beta],G - V(G^{r}[\beta]))$;
            \State 令$z$为$P_1$的最后一个顶点;
            \If{$z=v$} \ \Return $P_1$;
            \EndIf
            \State \Return (GHCP$(u,z,G - V(G^{r}[\beta]), F\setminus F_{\beta})$, $P_1^{-1}$);
        \ElsIf{$|F_{\alpha}|+|F_{\beta}|\leq 2k_1-2m_{r}-n+3$}
            \State $P_1 \gets $ PATHSEQ $(u, G^r[\alpha],G^r[\beta])$；
            \State 令$z$为$P_1$的最后一个顶点;
            \If{$z=v$} \ \Return $P_1$;
            \EndIf
            \State $P_1 += $GHCP$(z,v,G^r[\beta],F_{\beta})$;
            \State \Return $P_1$;
        \Else
            \State 选取一个子图$G^r[i]$，使得$|F\cap G^r[i]|=1$，其中$i \in \langle m_r-1 \rangle\setminus \{\alpha,\beta\}$;
            \State $G_{1} \gets G^r[i], F_{1} \gets F\cap V(G_{1})$;
            \State $P_1 \gets$ PATHSEQ$(u, F_{\alpha}\cup F_{1}, G^r[\alpha],G_{1})$;
            \State 令$x$为$P_1$的最后一个顶点;
            \State $P_2 \gets $ PATHSEQ$(v, F_{\beta}\cup F_{1}, G^r[\beta],G_{1})$;
            \State 令$y$为$P_2$的最后一个顶点;
            \If{$x=y$} \ \Return $P_1 + P_{2}^{-1}$;
            \EndIf
            \State $P_1 += $GHCP$(x,y,G_{1},F_1)$;
            \State \ \Return $P_{1} + P_{2}^{-1}$;
        \EndIf
    \ElsIf{$|F_{\alpha}|< k_2$} \ \Return (GHCP$(u,v,G^r[\alpha],F_{\alpha})$);
    \Else
        \State $P_1 \gets $PATHSEQ$(u, F, G^r[\alpha], G - V(G^{r}[\alpha]))$;
        \State 令$x$为$P_1$的最后一个顶点;
        \State $P_2 \gets $PATHSEQ$(v, F, G^r[\alpha], G - V(G^{r}[\alpha]))$;
        \State 令$y$为$P_2$的最后一个顶点;
        \If{$z$为$P_{1}$和$P_{2}$的第一个公共顶点}\ \Return Path$(P_{1},u,z) + $ Path$(P_{2}^{-1},z,v)$;
        \EndIf
        \State $P_1 += $GHCP$(x, y, G - V(G^{r}[\alpha]), F \setminus F_{\alpha})$;
        \State \ \Return $P_1 + P_{2}^{-1}$;
   \EndIf
\EndFunction%

 \Function{PATHSEQ}{$u,F,H_{1},H_{2}$} %\P
    \If {$(N_{G}(u)\cap V(H_{2})) \setminus F \neq \emptyset$}
        \State 从$(N_{G}(u)\cap V(H_{2})) \setminus F$中选择一个顶点$u_{1}$;
        \State \Return $(u,u_{1})$;
    \Else
        \ForAll {$(u_{1} \in N_{G}(u)\cap V(H_{1}))\setminus F$}
            \If {$(N_{G}(u_{1})\cap V(H_{2})) \setminus F \neq \emptyset$}
                \State 从$(N_{G}(u_{1})\cap V(H_{2})) \setminus F$ 中选择一个顶点$u_{2}$;
                \State \Return $(u,u_{1}, u_{2})$;
            \EndIf
        \EndFor
    \EndIf
    \State 从$(N_{G}(u)\cap V(H_{1})) \setminus F$ 中选择一个顶点$u_{1}$;
    \State $S \gets (N_{G}(u_1)\cap V(H_{1}))\setminus (F \cup (N_{G}(u)\cap V(H_{1})))$;
    \ForAll {$u_{2} \in S$}
        \If $(N_{G}(u_{2})\cap V(H_{2})) \setminus F \neq \emptyset$
            \State 从$(N_{G}(u_{2})\cap V(H_{2})) \setminus F$中选择一个顶点$u_{3}$;
            \State \Return $(u,u_{1},u_{2},u_{3})$;
        \EndIf
    \EndFor
 \EndFunction%

  \Function{GHCP}{$u,v,G,F$} %\P
    \State 在$G-F$中，从BuildPathSet$(G,u,v)$的$k_1$条路径中选一条无故障路径;
  \EndFunction%
\end{algorithmic}
\end{breakablealgorithm}

\subsection{容错路由算法分析}
在分析GHCFP的时间复杂度之前，
我们首先对函数PATHSEQ$(u,F,H_{1},H_{2})$
和GHCP$(x,$ $y,G,$ $F)$的时间复杂度进行分析。
对于函数PATHSEQ$(u,F,H_{1},H_{2})$，
其中$H_{1}$和$H_{2}$是$G$的两个子图且$u$在子图$H_{1}$中。
依据不同的情况，该函数可能会给出$u$到子图$H_{2}$的路径$(u,$ $u_1)$、$(u,$ $u_1,$ $u_2)$或$(u,$ $u_1,$ $u_2,$ $u_3)$。
PATHSEQ在不同的情形下执行的时间复杂度如下：
情形1. 所得到的路径为$(u,u_1)$。
若$(N_{G}(u)\cap V(H_{2}))\setminus F \neq \emptyset$，
则该函数从$(N_{G}(u)\cap V(H_{2})) \setminus F$中选择一个顶点$u_{1}$，
最终返回路径$(u,u_1)$。
该情况下的时间复杂度为$O(1)$。
情形2. 所得到的路径为$(u,u_1,u_2)$。
该函数首先会遍历集合$(N_{G}(u)\cap V(H_{1}))\setminus F$，令集合中每个顶点为$u_{1}$，
然后从$(N_{G}(u_{1})\cap V(H_{2})) \setminus F$ 中选择一个顶点$u_{2}$，
最终返回路径$(u,u_1,u_2)$。
该情况下的时间复杂度为$O(|N_{G}(u)\cap V(H_{1})|)\leq O(\kappa(G))$。
情形3. 所得到的路径为$(u,u_1,u_2,u_3)$。
在该情形下，该函数首先从$(N_{G}(u)\cap V(H_{1})) \setminus F$中选择一个顶点$u_{1}$，
并取集合$S \gets (N_{G}(u_1)\cap V(H_{1}))\setminus (F \cup (N_{G}(u)\cap V(H_{1}))$。
该过程的时间复杂度为$O(1)$。
然后函数会遍历集合$S$，令$u_{2}$为集合$S$中任一顶点。
之后从$(N_{G}(u_{2})\cap V(H_{2}))\setminus F$中选择一个顶点$u_{3}$，
最终返回路径$(u,u_1,u_2,u_3)$。
该情况的时间复杂度为$O(|S|)\leq O(\kappa(G))$。
综合情况1、情况2和情况3可得到函数PATHSEQ$(u,F,H_{1},H_{2})$的时间复杂度为$O(\kappa(G))$。
%如果存在一个无故障顶点$u_{1} \in N_{G}(u)\cap V(H_{2}) \setminus F$，
%那么这个函数会返回$(u,u_{1})$。
%因为$|N_{G}(u)\cap V(H_{2})|\leq|N_{G}(u)|=\kappa(G)$，
%所以得到路径$(u,u_{1})$的时间复杂度小于$O(\kappa(G))$。
%如果不存在无故障顶点$u_{1}$,
%该函数将继续寻找顶点$u_{2} \in N_{G}(u)\cap V(H_{1}) \setminus F$，
%然后调用函数PATHSEQ$(u_{2},F+\{u\},H_{1},H_{2})$ 来得到
%$u_{2}$到$H_{2}$的一条路径。
%接下来，该函数会返回一条无故障路径$(u,PATHSEQ(u_{2},F+\{u\},H_{1},H_{2}))$。
%类似地，找到顶点$u_{2}$的时间复杂度小于$O(\kappa(G))$。
%且，找到拼接顶点$u$和路径PATHSEQ$(u_{2},F+\{u\},H_{1},H_{2})$ 的时间复杂度为 $O(1)$。
%那么函数PATHSEQ$(u,F,H_{1},
%\\H_{2})$的时间复杂度
%小于$O(\kappa(G)+\kappa(G)+1)=O(\kappa(G))$。
%既然从 $u$到$H_{2}$的无故障路径的长度最大为$3$
%那么函数PATHSEQ$(u,F,H_{1},H_{2})$将被调用至多3 次，
%因此, 函数PATHSEQ$(u,F,H_{1},H_{2})$的时间复杂度是$O(\kappa(G)^3)$.

接下来，我们分析函数GHCP$(u,v,G,F)$的时间复杂度。
该函数首先调用函数BuildPathSet$(G,u,v)$\upcite{Guo2009BCube}，
得到$u$和$v$在$G-F$中的$\kappa(G)$条不相交路径。
该过程的时间复杂度为$O(\kappa(G)^2)$。
然后函数GHCP遍历这些不相交路径，
从中找出一条无故障路径。
其中，若判断一条路径是否为无故障路径需要判断路径中的每个顶点是否在故障集合$F$中。
因为每条路径中至多有$dist(u,v)+2$个顶点且$|F|=2\times\kappa(G)-n-1$，
所以该过程的时间复杂度为$O(dist(u,v)+2)\times O(2\times\kappa(G)-n-1)\leq O(\kappa(G)^2)$。
因为调用BuildPathSet总共得到$\kappa(G)$条路径，那么该判断至多执行$\kappa(G)$次。
综上所述，找到一条无故障路径的时间复杂度为$O(\kappa(G)^2)\times O(\kappa(G))=O(\kappa(G)^3)$。

最后，我们分析GHCFP的时间复杂度。
CHCFP在$\alpha \neq \beta$和$\alpha = \beta$两种情形下的时间复杂度如下。

情形1. $\alpha \neq \beta$。

情形1.1. $F_{\alpha}\geq k_2$。
GHCFP首先通过PATHSEQ$(u,G^r[\alpha],G - V(G^{r}[\alpha]))$
得到一条从$u$到$G-V(G^{r}[\alpha])$中的顶点$z$的$P_{1}$，
该过程的时间复杂度为$O(\kappa(G))$。
然后，若$z=v$，则GHCFP返回$P_{1}$。
因此，得到$u$和$v$在$G-F$中的一条无故障路径$P_{1}$的时间复杂度为$O(\kappa(G))$。
若$z\neq v$，GHCFP会返回路径$(P_{1},$GHCP$(z,v,G - V(G^{r}[\alpha]),F\setminus F_{\beta}))$。
该过程需要首先调用函数GHCP$(z,v,G - V(G^{r}[\alpha]),F\setminus F_{\beta})$构建一条无故障路径，
其时间复杂度为$O(\kappa(G)^3)$。
然后拼接$P_{1}$和上述GHCP$(z,v,G - V(G^{r}[\alpha]),F\setminus F_{\beta})$所构建的无故障路径，该过程的时间复杂度是$O(1)$。
因此，得到$u$和$v$在$G-F$中的无故障路径的时间复杂度为$O(\kappa(G))+O(\kappa(G)^3)+O(1) \leq O(\kappa(G)^3)$。

情形1.2. ($|F_{\beta}|\geq k_2$)或($|F_{\alpha}+F_{\beta}|\leq 2k_1-2m_{r}-n+3$)。
类似于在情形1.1中的讨论，我们得到$u$和$v$在$G-F$中的无故障路径的时间复杂度为$O(\kappa(G)^3)$。

情形1.3. $|F_{\alpha}+F_{\beta}|> 2k_1-2m_{r}-n+3$。
GHCFP首先会选择一个满足条件$|F\cap G^r[i]|=1$的子图$G^r[i]$，其中
$i \in \langle m_r \rangle\setminus \{\alpha,\beta\}$。
令$G_{1}=G^r[i]$，则该过程的由于时间复杂度为$O(m_{r}-2)\leq O(\kappa(G))$。
然后，GHCFP将得到一条从$u$到子图$G_{1}$中顶点$x$的无故障路径$P_{1}$
以及一条从$v$到子图$G_{1}$中顶点$u$的无故障路径$P_{2}$，
得到这两条路径的时间按复杂度分别为$O(\kappa(G))$。
接下来，若$x=y$，则GHCFP返回$P_{1}$。
因此，得到$G-F$中一条从$u$到$v$的无故障路径的时间复杂度为
$ O(\kappa(G)+2\times\kappa(G))\leq O(\kappa(G))$；
若$x\neq y$，则GHCFP返回路径$(P_{1},$GHCP$(x,y,G_{1},F\cap V(G_{1})),P_{2}^{-1})$。
该过程需要首先调用函数GHCP$(x,y,G_{1},F\cap V(G_{1}))$构建一条无故障路径，其时间复杂度为$O(\kappa(G)^3)$。
然后拼接$P_{1}$、上述GHCP$(x,y,G_{1},F\cap V(G_{1}))$所构建的无故障路径和$P_{2}^{-1}$，该过程的时间复杂度是$O(1)$。
因此，得到$G-F$中一条从$u$到$v$的一条无故障路径的时间复杂度为
$O(\kappa(G)+2\times\kappa(G)+\kappa(G)^3+1)\leq O(\kappa(G)^3)$。

情形2. $\alpha = \beta$。

情形2.1. $F_{\alpha}\leq k_2$。
GHCFP将直接调用算法GHCP$(u,v,G^r[\alpha],F_{\alpha})$构建一条无故障路径，
则该过程的时间复杂度为$O(\kappa(G)^3)$。

情形2.2. $F_{\alpha}>k_2$。
GHCFP将首先调用函数PATHSEQ得到一条从$u$到子图$G-V(G^r[\alpha])$中$x$的无故障路径$P_{1}$，
以及一条从$v$到子图$G-V(G^r[\alpha])$中的顶点$y$的无故障路径$P_{2}$。
这里得到$P_{1}$和$P_{2}$的时间复杂度分别为$O(\kappa(G))$。
然后，若$P_{1}$和$P_{2}$的存在公共顶点，令$z$为第一个公共顶点，
那么GHCFP将返回路径(Path$(P_{1},u,z)$, Path$(P_{2}^{-1},z,v))$。
因为$P_{1}$和$P_{2}$中至多有$dist(u,v)+2$个顶点，
所以得到公共顶点$z$的时间复杂度为$O(|V(P_{1})|\times |V(P_{2})|)\leq O((dist(u,v)+2)\times(dist(u,v)+2))\leq O(\kappa(G)^2)$。
因为得到路径$(P_{1},u,z)$的时间复杂度为$O(1)$，
因此，得到$G-F$中顶点$u$和$v$之间的一条无故障路径(Path$(P_{1},u,z)$, Path$(P_{2}^{-1},z,v))$
的时间复杂度为$O(2\times\kappa(G))+O(\kappa(G)^2) \leq O(\kappa(G)^2)$。
若$P_{1}$和$P_{2}$无公共顶点，GHCFP会返回路径
$(P_{1},$GHCP$(x,y,G - V(G^{r}[\alpha]),F \setminus F_{\alpha}),P_{2}^{-1})$。
该过程会先调用算法GHCP$(x,y,G - V(G^{r}[\alpha]),F \setminus F_{\alpha})$构建一条无故障路径，
它的时间复杂度为$O(\kappa(G)^3)$。
然后拼接$P_{1}$、上述GHCP$(x,y,G - V(G^{r}[\alpha]),F \setminus F_{\alpha})$所构建的无故障路径和$P_{2}^{-1}$，
该过程的时间复杂度为$O(1)$。
因此， 得到$u$和$v$在$G-F$中的一条无故障路径
$(P_{1},GHCP(x,y,G - V(G^{r}[\alpha]),F \setminus F_{\alpha}),P_{2}^{-1})$的时间复杂度为
$O(2\times\kappa(G)^2)+O(\kappa(G)^3)+O(1) \leq O(\kappa(G)^3)$。

综合以上所有情形，GHCFP的时间复杂度为$O(\kappa(G)^3)$。

\subsection{模拟实验}

本小节中对GHCFP用Python语言编程实现，
用一台配置为Intel Core i5-7200 CPU 2.71GHz与8 GB 内存的计算机进行模拟实验
并分析实验结果。
%根据定义\ref{GeneralizedHypercube}，广义超立方体的每个维度所包含的顶点数是随机的。
%实验中，我们设定广义超立方体的每个维度所包含的顶点数为$3$，
%及对于图$G(m_{r},m_{r-1},\ldots,m_{1})$，
%对于所有的$1 \leq  i\leq  r$，在模拟实验中令$m_i = 3$。
基于容错路由算法的目的是在较短时间内找到两个无故障顶点之间尽可能短的一条无故障路径。
本实验从执行效率和所获得的路径长度两个方面对GHCFP的性能进行测试。
同时，为了更好的模拟广义超立方体网络规模的扩大，
本模拟实验将分别从改变维数和改变基数两个方面进行实验。
其中，在改变基数的模拟实验中，我们基于$4$-维的广义超立方体进行测试。

GHCFP构建的是给出当广义超立方体的故障顶点数小于其$1$-限制连通度
且每个无故障顶点都至少有一个无故障邻居条件时，
$G(m_{r},m_{r-1},\ldots,m_{1})$中任意两个无故障顶点之间的一条无故障路径。
在本实验中，我们首先调用$random$函数随机生成故障顶点集合$F$，
满足：

(1)\;$F \subset V(G)$,

(2)\;$|F|=\kappa^1(G)-1$,

(3)\;$G-F$中每个顶点都存在至少一个邻居.\\
然后调用GHCFP和BFS分别构建出$G-F$中所有顶点到除自己以外的所有顶点之间的无故障路径。
我们针对实验结果进行以下分析。

分析一：
计算实验中GHCFP和BFS得到一条无故障路径需要花费的平均时间并进行对比，
其实验结果如图\ref{test1_1}和图\ref{test2_1}所示。
%根据实验结果，随着维度r的增加，两个算法得到一条无故障路径的所花费的平均CPU时长如图\ref{ch3_test3}所示，
%同时相同维度下，随着每维顶点个数的增加，实验结果如图\ref{test2_1}所示。

\begin{figure}[!h]
\centering
\includegraphics[width=15cm]{test1_1.eps}
\smallcaption{改变维数的情况下，得到一条无故障路径需要花费的平均时间}
\label{test1_1}
\end{figure}

\begin{figure}[!h]
\centering
\includegraphics[width=15cm]{test2_1.eps}
\smallcaption{改变基数的情况下，得到一条无故障路径需要花费的平均时间}
\label{test2_1}
\end{figure}

%正如我们对算法时间复杂度的理论分析，
从图\ref{test1_1}中可以看出GHCFP所花费的平均时长小于BFS。
尽管在维数较小时，GHCFP的所花费的时间与BFS所花费的时间相差不大
(如图\ref{test1_1}中的$3$-维$G(3,3,3)$和
$4$-维$G(3,3,3,3)$)。
但是随着维数的增加，GHCFP执行效率明显比BFS高。
根据实验结果可知，当$r = 7$时，
GHCFP和BFS所花费的平均CPU时间分别为$0.4$毫秒和$15.8$毫秒。
同时，从图\ref{test2_1}中可以看出，
在维数相同的情况下，随着基数的逐渐增大，BFS获取一条路径的
平均花费时间的增长速度要远大于GHCFP。
因此，从实验数据可以得到，本文算法的执行效率优于BFS的效率。

分析二：
分别计算实验中GHCFP和BFS所得到的
所有路径的平均长度并进行对比，
其实验结果如图\ref{test1_2}和图\ref{test2_2}所示。

\begin{figure}[!h]
\centering
\includegraphics[width=15cm]{test1_2.eps}
\smallcaption{改变维数的情况下，GHCFP和BFS得到所有路径的平均长度}
\label{test1_2}
\end{figure}
\begin{figure}[!h]
\centering
\includegraphics[width=15cm]{test2_2.eps}
\smallcaption{改变基数的情况下，GHCFP和BFS得到所有路径的平均长度}
\label{test2_2}
\end{figure}

从图\ref{test1_2}和图\ref{test2_2}中的数据可以看出，
GHCFP所得到的所有路径的平均长度略大于BFS的结果。
随着维数的增加或者基数的增大，
两者的差值逐渐减小，并接近于0。
也就是说，随着网络规模的扩大，
GHCFP所得到的路径长度很接近最短路径的长度或者等于最短路径的长度。

%实验3：
%在保证$G(m_{r},m_{r-1},\ldots,m_{1})$-条件连通且分别具有25到200 个故障顶点（以25递增）的前提下，
%由任一无故障顶点出发，构建到网络中所有无故障顶点的路径，计算成功率。
%该过程执行100次，得出三种算法的平均成功率。
%实验结果如图\ref{fig:4_3}所示。
%
%
%
%由于$Q_{10}$保证连通，所以BFS总能得出任意两个无故障顶点之间的最短路径。
%ABT算法和SPR算法在成功率上的表现差距不大。
%$Q_{10}$中共有1024个顶点，在故障顶点数达到200时（接近20\%），两种算法都能保持97\%以上的成功率。
%
分析三：
分别计算GHCFP和BFS获得的对应路径的差值，
然后统计所有差值的最小值、最大值、平均值及对应条数并进行对比。
实验结果如表\ref{test1_3}和表\ref{test2_3}所示。

\begin{table}[!htb]
\centering
\smallcaption{改变维数的情况下，两个算法路径差值的最小值，最大值和平均值} \label{test1_3}.
%\vspace{+23pt}
{%\small
    \begin{tabular}{|l|c|c|c|c|c|}
\hline
$G(m_{r},m_{r-1},\ldots,m_{1})$       &最小值  &条数  &最大值 &条数 &平均值\\
\hline
$G(3,3,3)$           &0    &271/342            &3    &4/342          &0.254385\\
$G(3,3,3,3)$         &0    &4525/4692          &2    &18/4692        &0.018115\\
$G(3,3,3,3,3)$       &0    &51152/51302        &2    &68/51302       &0.004249\\
$G(3,3,3,3,3,3)$     &0    &501624/501972      &2    &162/501972     &0.001015\\
$G(3,3,3,3,3,3,3)$   &0    &4673464/4676406    &2    &1436/4676406   &0.000093\\
\hline
\end{tabular}
}
\end{table}

\begin{table}[!htb]
\centering
\smallcaption{改变基数的情况下，两个算法路径差值的最小值，最大值和平均值} \label{test2_3}.
%\vspace{+23pt}
{%\small
    \begin{tabular}{|l|c|c|c|c|c|}
\hline
$G(m_{r},m_{r-1},\ldots,m_{1})$        &最小值  &条数   &最大值 &条数 &平均值\\
\hline
$G(3,3,3,3)$         &0    &4525/4692             &2    &18/4692    &0.018115\\
$G(3,3,3,4)$         &0    &8724/8742             &2    &18/8742    &0.013154\\
$G(3,3,4,4)$         &0    &16055/16256           &2    &4/16256    &0.014886\\
$G(3,4,4,4)$         &0    &29829/30102           &3    &2/30102    &0.010331\\
$G(3,4,4,5)$         &0    &47863/48180           &3    &2/48180    &0.007471\\
$G(3,4,4,6)$         &0    &70209/70490           &3    &2/70490    &0.004426\\
$G(3,4,5,6)$         &0    &112329/112560         &2    &18/112560  &0.002212\\
\hline
\end{tabular}
}
\end{table}
%\begin{figure}[!h]
%\centering
%\includegraphics[width=15cm]{test1_3.eps}
%\smallcaption{改变维数的情况下，两个算法所构造的路径差值的最小值、平均值和最大值}
%\label{test1_3}
%\end{figure}

%\begin{figure}[!h]
%\centering
%\includegraphics[width=15cm]{test2_3.eps}
%\smallcaption{改变基数的情况下，两个算法所构造的路径差值的最小值、平均值和最大值}
%\label{test2_3}
%\end{figure}

根据表\ref{test1_3}和表\ref{test2_3}中的数据，
从差值的最小值与对应条数可以看出，
GHCFP构建的所有路径中高于$90\%$的路径为最短路径，
并且随着维数或者基数的增大，该比例会增高。
然后，从差值的最大值与对应条数可以看出，
GHCFP构建的所有路径与BFS所构建的路径的长度差值的最大值为2或3，
且该类路径占比较小，
并且随着维数或者基数的增大，该比例会减少。
另外，明显可以看出两个算法所得到的路径长度差值的平均值
随着网络规模的扩大，逐渐减小甚至接近于0。
该实验结果表明GHCFP所得到的路径的路径长度整体是较优的。

综合以上分析可得，GHCFP相较于BFS在执行效率上表现良好，
且GHCFP所得到的路径中绝大部分路径的长度接近于最短路径的长度或者等于最短路径的长度。

\section{本章小结}

基于限制连通度的定义，
本章给出了广义超立方体的$1$-限制连通度，
并给出了满足总故障顶点数小于$1$-限制连通度，
且故障网络中每个无故障顶点都至少有一个无故障邻居条件的
容错路由算法。本章的主要研究成果具体如下：

\hangafter 1 %保留第一行的原格式
\hangindent 3em %悬挂缩进3字符
1. 证明了$r$-维广义超立方体$G(m_{r},m_{r-1},\ldots,m_{1})$
的$1$-限制连通度是$2\kappa(G(m_{r},m_{r-1},\ldots,$ $m_{1}))-n$，
其中$n=\max\{m_{1},m_{2},\ldots,m_{r}\}$。

\hangafter 1 %保留第一行的原格式
\hangindent 3em %悬挂缩进3字符
2. 给出了一个满足$1$-限制连通度条件的容错路由算法GHCFP，
且该算法的时间复杂度为$O(\kappa(G)^{3})$。

相关成果发表在SCI源期刊
《International Journal Foundation of Computer Science》
上(第一作者，2017年发表)。
%\section{网格网络的$k^{*}$-容器}
%
%在这一小节，我们讨论网格网络的$k^{*}$-容器。
%我们得出的结果如下：
%（1）假设$u$和$v$是$M_{m,n}$中的任意两个不同顶点，如果$\{u, v\} \subseteq A_{m,n}$，那么$u$ 和$v$之间存在一个$1^{*}$-容器，其中$m$和$n$ 是奇数且$\min \{m, n\} \geq 3$；
%（2）假设$u$和$v$是$M_{m,n}$中的任意两个不同顶点，如果$\{u, v\} \subseteq B_{m,n}$，那么$u$ 和$v$之间存在一个$3^{*}$-容器，其中$m$和$n$ 是奇数且$\min \{m, n\} \geq 3$；
%（3）$s\kappa^{L}(M_{m,n})=3$，其中$m$是偶数且$\min \{m, n\} \geq 4$；
%（4）假设$u$和$v$是$\\M_{m,n}$中任意两个不同部的顶点，如果$u \notin \{ (1,1), (1,n-2), (m-2,1), (m-2,n-2)\}$且$v \notin\{ (1,1), (1,n-2), (m-2,1), (m-2,n-2)\}$，那么$u$和$v$之间存在一个$4^{*}$-容器，其中$m$是偶数且$\min \{m, n\} \geq 6$。
%下面是本章所需的引理。
%
%\begin{lem}
%\label{lem_hamiltoianPath_1}
%在$m \geq 4$且$n \geq 4$ 的$M_{m,n}$中，如果$|A_{m,n}|=|B_{m,n}|$，对于任意两个属于不同部的顶点$s$和顶点$t$，存在一条从$s$到$t$的哈密顿路；如果$|A_{m,n}|=|B_{m,n}|+1$，对于属于$A_{m,n}$的任意两个顶点$s$ 和顶点$t$，存在一条从$s$到$t$ 的哈密顿路\upcite{Itali1982}。
%\end{lem}
%
%\begin{lem}
%\label{lem_hamiltoianPath_2}
%  假设$u$和$v$是$M_{3,3}$中任意两个不同顶点，如果$\{ u, v \} \subset A_{3,3}$，那么$u$和$v$之间存在一个$1^{*}$-容器；如果$\{ u, v \} \subset B_{3,3}$，那么$u$ 和$v$之间存在一个$3^{*}$-容器。
%\end{lem}
%
%\begin{proof}
%假设$u$和$v$是$M_{3,3}$中任意两个不同顶点，如果$\{ u, v \} \subset A_{3,3}$，那么$u$和$v$ 之间的$1^*$-容器如图\ref{fig:1-pathIn3by3} 所示。
%如果$\{ u, v \} \subset B_{3,3}$，那么$u$和$v$ 之间的$3^*$- 容器如图\ref{fig:3-pathIn3by3}所示。
%\end{proof}
%
%\begin{figure}[!htbp]
%\centering
%\includegraphics[width=\imgsize\textwidth]{1-pathIn3by3.eps}
%\smallcaption{$M_{3,3}$中的顶点$u$和顶点$v$之间的$1^*$-容器}
%\label{fig:1-pathIn3by3}
%\end{figure}
%
%\begin{figure}[!htbp]
%\centering
%\includegraphics[width=60mm]{3-pathIn3by3.eps}
%\smallcaption{$M_{3,3}$中顶点$u$和顶点$v$之间的$3^*$-容器}
%\label{fig:3-pathIn3by3}
%\vspace{-10pt}
%\end{figure}
%
%
%\begin{thm}
%\label{thm_hamiltoianPath_3}
% 假设$u$和$v$是$M_{m,n}$中任意两个不同顶点，如果$\{ u, v \} \subset A_{m,n}$，那么$u$和$v$之间存在一个$1^{*}$-容器，其中$m$ 和$n$均是奇数且$\min \{m, n\} \geq 3$。
%\end{thm}
%\begin{proof}
%根据引理\ref{lem_hamiltoianPath_1}，可知当$\min \{m, n\} \geq 4$ 时定理成立。
%接下来，只需要证明$m = 3$或$n = 3$时定理成立。
%不失一般性，假设$m = 3$，对$n$进行归纳证明。
%根据引理\ref{lem_hamiltoianPath_2}，可知当$m = 3$且$n = 3$ 时定理成立，所以我们使用$M_{3,3}$作为归纳基础。
%
%假设$M_{3,n-2}$中任意两个属于$A_{m,n}$的顶点之间存在一个$1^{*}$- 容器，
%接下来，我们只需证明$M_{3,n}$中任意两个属于$A_{m,n}$的顶点之间存在一个$1^{*}$-容器定理成立即可，其中$n \geq 5$。
%
%
%令$u = (u_{i},u_{j})$且$v = (v_{i},v_{j})$，不失一般性，假设$u_{j} \leq v_{j}$。
%根据$u$和$v$的位置分布情况，分为以下两种情形讨论。
%
%%情形1. 顶点$u$和顶点$v$的外面有两列。
%%情形1. 有两个相邻的边界列。
%情形1. $u_{j} \notin \{0, 1\}$且$v_{j} \notin \{0, 1\}$或$u_{j} \notin \{n-2, n-1\}$ 且$v_{j} \notin \{n-2, n-1\}$。
%
%不失一般性，假设$u_{j} \notin \{n-2, n-1\}$ 且$v_{j} \notin \{n-2, n-1\}$。
%即$\{ u,v\} \cap \{ (x,y) \mid 0 \leq x \leq 2 $ 且 $n-2 \leq  y \leq  n-1 \}= \emptyset $。
%接下来，令$a_{1}=(0,n-3)$，$a_{2}=(1,n-3)$且$a_{3}=(2,n-3)$。
%根据归纳假设, 我们可以得到顶点$u$和顶点$v$之间的一条路径$P$，且$P$覆盖$Mesh(0:2,0:n-3)$中的所有顶点。
%因为$deg_{M_{3,n-2}}(a_{2}) = 3$且$a_{2} \in B_{3,n-2}$, 所以$\langle a_{1}, a_{2}\rangle$或$\langle a_{2}, a_{3}\rangle$是路径$P$中的一部分。
%
%如果$\langle a_{1}, a_{2}\rangle$是路径$P$的一部分，那么我们设$\{ x, y\} = \{ a_{1}, a_{2}\}$；如果$\langle a_{2}, a_{3}\rangle$ 是路径$P$ 中的一部分，那么设
%$\{ x, y\} = \{ a_{2}, a_{3}\}$。
%所以，我们可以得到路径$P = \langle u, R_{1}, x, y, R_{2}, v \rangle$ （注意$R_{1}$和$R_{2}$是路径$P$的一部分，如果$u = x$，那么$R_{1} = \emptyset$；如果$v = y$，那么$R_{2} = \emptyset$）。
%接下来，我们设$Q_{1} = \langle (0,n-2), (0,n-1), (1,n-1), (2,n-1), (2,n-2), (1,n-2) \rangle$， $Q_{2} = \langle (1,n-2), (2,n-2), (2,n-1), (1,n-1), (0,n-1), (0,n-2) \rangle$， $Q_{3} = \langle (1,n-2), (0,n-2), (0,n-1), (1,n-1), (2,n-1), (2,n-2) \rangle$ 和$Q_{4} = \langle (2,n-2), (2,n-1), (1,n-1), (0,n-1), (0,n-2), (1,n-2) \rangle$。
%所以，我们可以得到$M_{3,n}$中顶点$u$和顶点$v$之间的$1^*$- 容器：$\langle u, R_{1}, x, Q, y, R_{2}, v \rangle$，其中$Q$ 的取值如下所示：
%\begin{align}
%      Q = \left\{ \begin{array}{ll}\notag
%       Q_{1}   \ \ \ \textrm{如果} \ x = a_{1}  \ \textrm{且} y = a_{2} \\
%       Q_{2}   \ \ \ \textrm{如果} \ x = a_{2}  \ \textrm{且} y = a_{1} \\
%       Q_{3}   \ \ \ \textrm{如果} \ x = a_{2}  \ \textrm{且} y = a_{3} \\
%       Q_{4}   \ \ \ \textrm{如果} \ x = a_{3}  \ \textrm{且} y = a_{2} \\
%    \end{array}\right.
%\end{align}
%
%%%%%如图\ref{fig:example2_mesh}中所示，我们给出了$M_{3,5}$ 中$u = (0,0)$且$v = (0,2)$时的$1^{*}$-容器。
%%%%%\begin{figure}[!htbp]
%%%%%\centering
%%%%%\includegraphics[width=125mm]{example2_mesh.eps}
%%%%%\smallcaption{$M_{3,5}$中$u = (0,0)$且$v = (0,2)$时的$1^{*}$- 容器}
%%%%%\label{fig:example2_mesh}
%%%%%\vspace{-10pt}
%%%%%\end{figure}
%
%%情形2. 顶点$u$和顶点$v$的外面没有两列。
%%情形2. 没有两个相邻的边界列。
%情形2. $u_{j} \in \{0, 1\}$且$v_{j} \in \{n-2, n-1\}$。
%即$u$位于$M_{3,n}$最左边的两列且$v$位于$M_{3,n}$最右边的两列。
%
%在此情形中，我们设$a=(0,n-3)$。
%根据归纳假设，我们可以得到顶点$u$和顶点$a$之间的路径$P$，且$P$ 覆盖$Mesh(0:2,0:n-3)$中的所有顶点。
%不失一般性，我们设$P = \langle u, R, a \rangle$。
%接下来，我们设$Q_{1} = \langle (0,n-2), (1,n-2), (2,n-2), (2,n-1), (1,n-1)\rangle$，$Q_{2} = \langle (0,n-2), (0,n-1), (1,n-1), (1,n-2), (2,n-2)\rangle$ 和$Q_{3} = \langle (0,n-2), (0,n-1), (1,n-1), (2,n-1), (2,n-2)\rangle$。
%所以，我们可以得到$M_{3,n}$中顶点$u$和顶点$v$之间的$1^*$- 容器：$\langle u, R, a, Q, v \rangle$，其中$Q$的取值如下所示：
%\begin{align}
%      Q = \left\{ \begin{array}{ll}\notag
%       Q_{1}   \ \ \ \textrm{如果} \ v = (0,n-1) \\
%       Q_{2}   \ \ \ \textrm{如果} \ v = (2,n-1) \\
%       Q_{3}   \ \ \ \textrm{如果} \ v = (1,n-2) \\
%    \end{array}\right.
%\end{align}
%
%%%%%如图\ref{fig:example3_mesh}中所示，我们给出了$M_{3,5}$ 中$u = (0,0)$且$v = (0,4)$时的$1^{*}$-容器。
%%%%%\begin{figure}[!htbp]
%%%%%\centering
%%%%%\includegraphics[width=100mm]{example3_mesh.eps}
%%%%%\smallcaption{$M_{3,5}$中$u = (0,0)$且$v = (0,4)$时的$1^{*}$- 容器}
%%%%%\label{fig:example3_mesh}
%%%%%\vspace{-10pt}
%%%%%\end{figure}
%综上所述，顶点$u$和顶点$v$之间存在一个$1^{*}$- 容器，此定理得证。
%\end{proof}
%
%%%接下来证明本章的第二个结果。
%
%\begin{thm}
%\label{thm_hamiltoianPath_4}
% 假设$u$和$v$是$M_{m,n}$中任意两个不同顶点，如果$\{ u, v \} \subset B_{m,n}$，那么$u$和$v$之间存在一个$3^{*}$-容器，其中$m$ 和$n$均是奇数且$\min \{m, n\} \geq 3$。
%\end{thm}
%
%\begin{proof}
%根据$m$和$n$的大小，我们分为以下两种情形证明。
%
%情形1. $m = 3$或$n = 3$。
%
%不失一般性，假设$m = 3$，对$n$进行归纳证明。
%根据引理\ref{lem_hamiltoianPath_2}，可知当$m = 3$且$n = 3$ 时定理成立，所以我们使用$M_{3,3}$作为归纳基础。
%假设$M_{3,n-2}$中任意两个属于$B_{m,n}$的顶点之间存在一个$3^{*}$- 容器。
%接下来，我们只需证明$M_{3,n}$中任意两个属于$B_{m,n}$的顶点之间存在一个$3^{*}$-容器即可，其中$n \geq 5$。
%
%令$u = (u_{i},u_{j})$且$v = (v_{i},v_{j})$，不失一般性，假设$u_{j} \leq  v_{j}$。
%%根据有没有两列在顶点$u$和顶点$v$的外面, 我们分成以下两种情形证明。
%%%根据有没有两个相邻的边界列，我们分成以下两种情形证明。
%根据$u$和$v$的位置分布情况，分为以下两种情形讨论。
%
%%情形1.1. 顶点$u$和顶点$v$的外面有两列。
%%情形1.1. 有两个相邻的边界列。
%情形1.1. $u_{j} \notin \{0, 1\}$且$v_{j} \notin \{0, 1\}$ 或$u_{j} \notin \{n-2, n-1\}$且$v_{j} \notin \{n-2, n-1\}$。
%
%此种情形和定理\ref{thm_hamiltoianPath_3}中的情形1.1类似。
%不失一般性，假设$u_{j} \notin \{n-2, n-1\}$ 且$v_{j} \notin \{n-2, n-1\}$。
%即$\{ u,v\} \cap \{ (x,y) \mid 0 \leq  x \leq  2 $ 且 $n-2 \leq  y \leq  n-1 \}= \emptyset $。
%接下来，令$a_{1}=(0,n-3)$和$a_{2}=(1,n-3)$。
%根据归纳假设, 我们可以得到顶点$u$和顶点$v$之间的三条路径$P_{1}^{'}$，$P_{2}^{'}$和$P_{3}^{'}$，且这三条路径覆盖$Mesh(0:2,0:n-3)$ 中的所有顶点。
%因为$deg_{M_{3,n-2}}(a_{1}) = 2$且$a_{1} \in A_{3,n-2}$, 所以$\langle a_{1}, a_{2}\rangle$一定是某条路径中的一部分。
%不失一般性，假设$\langle a_{1}, a_{2}\rangle$是路径$P_{1}^{'}$ 的一部分，且设$\{ x, y\} = \{ a_{1}, a_{2}\}$。
%所以，我们可以得到$P_{1}^{'} = \langle u, R_{1}, x, y, R_{2}, v \rangle$（注意$R_{1}$和$R_{2}$是路径$P_{1}^{'}$的一部分，如果$u = x$，那么$R_{1} = \emptyset$；如果$v = y$，那么$R_{2} = \emptyset$。），$P_{2}^{'} = \langle u, R_{3}, v \rangle$和$P_{3}^{'} = \langle u, R_{4}, v \rangle$。
%接下来，我们设$Q_{1} = \langle (0,n-2), (0,n-1), (1,n-1), (2,n-1), (2,n-2), (1,n-2) \rangle$和$Q_{2} = \langle (1,n-2), (2,n-2), (2,n-1), (1,n-1), (0,n-1), (0,n-2) \rangle$。
%所以，我们可以得到$M_{3,n}$中顶点$u$和顶点$v$之间的$3^*$- 容器$\{P_{1}, P_{2}, P_{3}\}$，其中$P_{1} = \langle u, R_{1}, x, Q, y, R_{2}, v \rangle$，$P_{2} = \langle u, R_{3}, v \rangle$，$P_{3} = \langle u, R_{3}, v \rangle$，而$Q$的取值如下所示：
%\begin{align}
%       Q = \left\{ \begin{array}{ll}\notag
%       Q_{1}   \ \ \ \textrm{如果} \ x = a_{1}  \ \textrm{且} y = a_{2} \\
%       Q_{2}   \ \ \ \textrm{如果} \ x = a_{2}  \ \textrm{且} y = a_{1} \\
%    \end{array}\right.
%\end{align}
%
%
%%%%%如图\ref{fig:example4_mesh}中所示，我们给出了$M_{3,5}$ 中$u = (0,1)$且$v = (1,2)$时的$3^{*}$-容器。
%
%%%%%\begin{figure}[!htbp]
%%%%%\centering
%%%%%\includegraphics[width=100mm]{example4_mesh.eps}
%%%%%\smallcaption{$M_{3,5}$中$u = (0,1)$且$v = (1,2)$时的$3^{*}$- 容器}
%%%%%\label{fig:example4_mesh}
%%%%%\vspace{-10pt}
%%%%%\end{figure}
%
%%情形1.2. 顶点$u$和顶点$v$的外面没有两列。
%%情形1.2. 没有两个相邻的边界列。
%情形1.2. $u_{j} \in \{0, 1\}$且$v_{j} \in \{n-2, n-1\}$。
%即$u$位于$M_{3,n}$最左边的两列且$v$位于$M_{3,n}$最右边的两列。
%
%在这种情形中，设$a=(1,n-3)$，$b_{1}=(0,n-3)$，$b_{2}=(1,n-4)$和$b_{3}=(2,n-3)$。
%根据归纳假设，我们可以得到顶点$u$和顶点$a$之间的三条路径$P_{1}^{'}$，$P_{2}^{'}$和$P_{3}^{'}$，且它们覆盖$Mesh(0:2,0:n-3)$中的所有顶点。
%不失一般性，设$P_{i}^{'} = \langle u, R_{i}, b_{i}, a \rangle$，其中$1 \leq  i \leq  3$ （注意有可能$R_{i}= \emptyset$）。
%根据$v$位置的不同，$M_{3,n}$中顶点$u$和顶点$v$ 之间的$3^*$- 容器$\{ P_{1}, P_{2}, P_{3}\}$如下所示：
%
%如果$v = (0,n-2)$，那么我们得到$ P_{1}=\langle u, R_{1}, b_{1}, v \rangle $， $ P_{2}=\langle u, R_{2}, b_{2}, a, (1,n-2), v \rangle $和$P_{3}=\langle u, R_{3}, b_{3}, (2,n-2), R(2:0,n-1), v \rangle $。
%
%如果$v =(2,n-2)$，那么我们得到$P_{1}=\langle u, R_{1}, b_{1}, (0,n-2), R(0:2,n-1), v \rangle$， $P_{2}=\langle u, R_{2}, b_{2}, a, (1,n-2), v \rangle$ 和$P_{3}=\langle u, R_{3}, b_{3}, v \rangle$。
%
%如果$v = (1,n-1)$，那么我们得到$P_{1}=\langle u, R_{1}, b_{1}, (0,n-2), (0,n-1), v \rangle$， $P_{2}=\langle u, R_{2}, b_{2}, a, (1,n-2), v \rangle$ 和$P_{3}=\langle u, R_{3}, b_{3}, (2,n-2), (2,n-1), v \rangle$。
%
%%%%%如图\ref{fig:example5_mesh}中所示，我们给出了$M_{3,5}$ 中$u = (0,1)$且$v = (0,3)$时的$3^{*}$-容器。
%%%%%
%%%%%\begin{figure}[!htbp]
%%%%%\centering
%%%%%\includegraphics[width=100mm]{example5_mesh.eps}
%%%%%\smallcaption{$M_{3,5}$中$u = (0,1)$且$v = (0,3)$时的$3^{*}$- 容器}
%%%%%\label{fig:example5_mesh}
%%%%%\vspace{-10pt}
%%%%%\end{figure}
%
%情形2. $m \geq 5$且$n \geq 5$。
%
%%根据对称性，我们可以通过旋转$M_{t,s}$得到$M_{s,t}$。
%如果$u$和$v$不在$M_{m,n}$中的最上面两行或最下面两行或最左面两列或最右面两列，我们可以和情形1.1 中一样处理。
%否则，顶点$u$和顶点$v$一定分别位于$M_{m,n}$中的最上面、最下面两行，且分别位于$M_{m,n}$中的最左面、最右面两列。
%%否则，$\{u_{i}, u_{j}\} \subseteq \{0, 1\}$且$\{v_{i},v_{j}\} \subseteq \{m-2, m-1\}$。
%不失一般性，假设$u_{i} \leq  v_{i}$且$u_{j} \leq  v_{j}$，则$u$ 一定是$(0,1)$和$(1,0)$中的一个，$v$一定是$(m-2,n-1)$和$(m-1,n-2)$ 中的一个。
%设$a=(1,1)$和$b=(m-2,n-2)$。
%显而易见，不论$u$是$(0,1)$还是$(1,0)$，$a$一定是$u$的邻居顶点。
%同样地，$b$一定是$v$的邻居顶点。
%因为$m-2 \geq 3$且$n-2 \geq 3$，根据定理\ref{thm_hamiltoianPath_3}，我们可以得到顶点$a$和顶点$b$之间的一条路径$P^{'}$，且$P^{'}$覆盖了$Mesh(1:m-2,1:n-2)$中所有的顶点。
%不失一般性，设$P^{'} = \langle a, R, b \rangle$。
%
%如果$u=(0,1)$，那么根据$v$的不同位置，$M_{m,n}$ 中顶点$u$ 和$v$ 之间的$3^*$-容器$\{ P_{1}, P_{2}, P_{3}\}\\$如下所示：
%
%如果$v = (m-2,n-1)$，那么我们设$P_{1}=\langle u, R(0:m-1,0), R(m-1,1:n-1), v \rangle$，$P_{2}=\langle u, R(0,2:n-1), R(1:m-3,n-1), v \rangle$和$P_{3}=\langle u, a, R, b, v \rangle$。
%
%如果$v = (m-1,n-2)$，那么我们设$P_{1}=\langle u, R(0:m-1,0), R(m-1,1:n-3), v \rangle$，$P_{2}=\langle u, R(0,2:n-1), R(1:m-1,n-1), v \rangle$和$P_{3}=\langle u, a, R, b, v \rangle$。
%
%如果$u=(1,0)$，那么根据$v$的不同位置，$M_{m,n}$ 中顶点$u$ 和$v$ 之间的$3^*$-容器$\{ P_{1}, P_{2}, P_{3}\}\\$如下所示：
%
%如果$v = (m-2,n-1)$，那么我们设$P_{1}=\langle u, R(2:m-1,0), R(m-1,1:n-1), v \rangle$，$P_{2}=\langle u, R(0,0:n-1), R(1:m-3,n-1), v \rangle$和$P_{3}=\langle u, a, R, b, v \rangle$。
%
%如果$v = (m-1,n-2)$，那么我们设$P_{1}=\langle u, R(2:m-1,0), R(m-1,1:n-3), v \rangle$，$P_{2}=\langle u, R(0,0:n-1), R(1:m-1,n-1), v \rangle$和$P_{3}=\langle u, a, R, b, v \rangle$。
%
%%%%%如图\ref{fig:example6_mesh}中所示，我们给出了$M_{5,5}$ 中$u = (0,1)$且$v = (3,4)$时的$3^{*}$-容器。
%%%%%
%%%%%\begin{figure}[!htbp]
%%%%%\centering
%%%%%\includegraphics[width=50mm]{example6_mesh.eps}
%%%%%\smallcaption{$M_{5,5}$中$u = (0,1)$且$v = (3,4)$时的$3^{*}$- 容器}
%%%%%\label{fig:example6_mesh}
%%%%%%%%%\vspace{-10pt}
%%%%%\end{figure}
%
%综上所述，顶点$u$和顶点$v$之间存在一个$3^{*}$- 容器，此定理得证。
%\end{proof}
%
%%%接下来证明本章的第三个结果。
%
%\begin{lem}
%\label{lem_hamiltoianPath_5}
%  假设$u$和$v$是$M_{m,n}$中任意两个不同顶点，如果$u \in A_{m,n}$ 且$v \in B_{m,n}$，那么$u$和$v$之间存在一个$3^{*}$-容器，其中$m$ 是偶数且$\min \{m, n\} \geq 4$。
%\end{lem}
%\vspace{-10pt}
%
%\begin{proof}
%根据$n$的奇偶性，我们分为以下两种情形讨论。
%
%情形1. $n$是偶数。
%当$m = 4$且$n = 4$时，根据顶点$u$和顶点$v$的不同位置分布, 有6种情形。
%这6种情形中顶点$u$和顶点$v$之间的$3^*$-容器$\{ P_{1}, P_{2}, P_{3}\}$ 如图\ref{fig:3-pathIn4by4} 所示。
%
%\begin{figure}[!htbp]
%\centering
%\includegraphics[width=90mm]{3-pathIn4by4.eps}
%\smallcaption{$M_{4,4}$中顶点$u$和顶点$v$之间的$3^*$-容器}
%\label{fig:3-pathIn4by4}
%\vspace{-10pt}
%\end{figure}
%
%%%\iffalse
%%%我们原打算像前文所述一样通过判断有没有两行或两列在顶点$u$ 和顶点$v$ 的外面，从而分成两种情形证明。
%%%但是，如图\ref{fig:counter_example1}所示，当$u = (0,2)$，$v = (0,n-3)$时，如果$n \geq 6$，存在两列在$M_{4,n}$中的顶点$u$和顶点$v$的外面。
%%%我们用最右边两列举例说明，显而易见，在由最左面$n - 2$列顶点构成的$M_{4,n-2}$中，因为$deg_{M_{4,n-2}}(v) = 2$，顶点$u$和顶点$v$之间是没有$3^*$容器的。
%%%我们把这样的两列称作虚假列。
%%%同样地，我们最左面两列也是虚假列。因为我们讨论的是$m \geq 4$ 的情形，所以也不能考虑存在两行在顶点$u$和顶点$v$的外面。
%%%所以，这种$M_{4,n}$的情形是无法从归纳基础得到的，此情形中的顶点$u$和顶点$v$之间的$3^*$ 容器：$\{ P_{1}, P_{2}, P_{3}\}$分为以下两种情形。
%
%%%\begin{figure}
%%%\centering
%%%\includegraphics[width=\imgsize\textwidth]{counter_example1}
%%%\smallcaption{情形1中无法通过归纳假设得到的$M_{4,n}$。}
%%%\label{fig:counter_example1}
%%%\end{figure}
%
%%%如果$n = 6$，则$\{ P_{1}, P_{2}, P_{3}\}$如下所示：
%%%\begin{align}
%%%       \left\{ \begin{array}{ll}\notag
%%%       P_{1}=\langle u, v \rangle\\
%%%       P_{2}=\langle u, (1,2), (1,1), R(2,1:4), (1,4), (1,3), v \rangle\\
%%%       P_{3}=\langle u, (0,1), R(0:2,0), R(3,0:5), R(2:0,5), (0,4), v \rangle\\
%%%       \end{array}\right.
%%%\end{align}
%
%%%如果$n \geq 8$，则$\{ P_{1}, P_{2}, P_{3}\}$ 如下所示：
%%%\begin{align}
%%%       \left\{ \begin{array}{ll}\notag
%%%       P_{1}=\langle u, Q(0:1,3:n-4), v \rangle\\
%%%       P_{2}=\langle u, (1,2), (1,1), R(2,1:n-2), (1,n-2), (1,n-3), v \rangle\\
%%%       P_{3}=\langle u, (0,1), R(0:2,0), R(3,0:n-1), R(2:0,n-1), (0,n-2), v \rangle\\
%%%      \end{array}\right.
%%%\end{align}
%%%\fi
%我们使用$M_{4,4}$作为归纳基础，假设$M_{m-2,n-2}$中任意两个不同部的顶点之间存在一个$3^{*}$-容器。
%接下来，我们只需证明$M_{m,n}$中任意两个不同部的顶点之间存在一个$3^{*}$-容器即可，其中$m \geq 6$ 且$n \geq 6$。
%设$u = (u_{i},u_{j})$和$v = (v_{i},v_{j})$，不失一般性，假设$u_{i} \leq  v_{i}$且$u_{j} \leq  v_{j}$。
%%根据对称性，我们可以通过旋转$M_{t,s}$得到$M_{s,t}$。
%%根据有没有两行或两列在$M_{m,n}$中顶点$u$和顶点$v$的外面，分成两种情形证明。
%%根据$M_{m,n}$中有没有两个相邻的边界列或边界行，分成两种情形证明。
%根据$u$和$v$的位置分布情况，分为以下两种情形讨论。
%
%%情形1.1. 有两行或两列在$M_{m,n}$中顶点$u$和顶点$v$的外面。
%%情形1.1. $M_{m,n}$中有两个相邻的边界列或边界行。
%情形1.1. $u_{j} \notin \{0, 1\}$且$v_{j} \notin \{0, 1\}$，或$u_{j} \notin \{n-2, n-1\}$ 且$v_{j} \notin \{n-2, n-1\}$，或$u_{i} \notin \{0, 1\}$ 且$v_{i} \notin \{0, 1\}$，或$u_{i} \notin \{m-2, m-1\}$且$v_{i} \notin \{m-2, m-1\}$。
%不失一般性，假设$u_{i} \notin \{m-2, m-1\}$ 且$v_{i} \notin \{m-2, m-1\}$。
%即$\{ u,v\} \cap \{ (x,y) \mid m-2 \leq  x \leq  m-1 $ 且 $0 \leq  y \leq  n-1 \}= \emptyset $。
%
%如果$v = (m-3,0)$，那么令$v^{'} = (m-3,2)$。
%根据归纳假设，我们可以得到$u$和$v^{'}$之间的三条不相交路径$P_{1}^{'}$，$P_{2}^{'}$和$P_{3}^{'}$，且它们覆盖了$Mesh(0:m-3,0:n-1)$ 中的所有顶点。
%显而易见，我们可以设$P_{1}^{'} = \langle u, R_{1}, (m-4,0), v, (m-3,1), v^{'} \rangle$，$P_{2}^{'} = \langle u, R_{2}, (m-4,2), v^{'} \rangle$和$P_{3}^{'} = \langle u, R_{3}, (m-3,3), v^{'} \rangle$。
%接下来， 我们就可以得到$M_{m,n}$中$u$和$v$之间的$3^*$-容器$\{ P_{1}, P_{2}, P_{3}\}$，如下所示：
%\begin{align}
%       \left\{ \begin{array}{ll}\notag
%       P_{1}=\langle u, R_{1}, (m-4,0), v \rangle\\
%       P_{2}=\langle u, R_{2}, (m-4,2), v^{'}, (m-3,1), v \rangle\\
%       P_{3}=\langle u, R_{3}, (m-3,3), R(m-2,3:n-1), R(m-1,n-1:3), (m-1,2), \\ \quad \quad \quad (m-2,2), (m-2,1), (m-1,1), (m-1,0), (m-2,0), v \rangle\\
%       \end{array}\right.
%\end{align}
%
%如果$v = (m-3,n-1)$，那么令$v^{'} = (m-3,n-3)$。
%根据归纳假设，我们可以得到$u$和$v^{'}$之间的三条不相交路径$P_{1}^{'}$，$P_{2}^{'}$和$P_{3}^{'}$，且它们覆盖了$Mesh(0:m-3,0:n-1)$ 中的所有顶点。
%显而易见，我们可以设$P_{1}^{'} = \langle u, R_{1}, (m-4,n-1), v, (m-3,n-2), v^{'} \rangle$，$P_{2}^{'} = \langle u, R_{2}, (m-4,n-3), v^{'} \rangle$ 和$P_{3}^{'} = \langle u, R_{3}, (m-3,n-4), v^{'} \rangle$。
%接下来， 我们就可以得到$M_{m,n}$中$u$和$v$之间的$3^*$-容器$\{ P_{1}, P_{2}, P_{3}\}$，如下所示：
%\begin{align}
%       \left\{ \begin{array}{ll}\notag
%       P_{1}=\langle u, R_{1}, (m-4,n-1), v \rangle\\
%       P_{2}=\langle u, R_{2}, (m-4,n-3), v^{'}, (m-3,n-2), v \rangle\\
%       P_{3}=\langle u, R_{3}, (m-3,n-4), R(m-2,n-4:0), R(m-1,0:n-4), (m-1,n-3), \\ \quad \quad \quad (m-2,n-3), (m-2,n-2), (m-1,n-2), (m-1,n-1), (m-2,n-1), v \rangle\\
%       \end{array}\right.
%\end{align}
%%%%%如图\ref{fig:example7_mesh}中所示，我们给出了$M_{6,4}$ 中当$u = (1,1)$且$v = (3,0)$时的$3^{*}$-容器。
%%%%%
%%%%%\begin{figure}[!htbp]
%%%%%\centering
%%%%%\includegraphics[width=90mm]{example7_mesh.eps}
%%%%%\smallcaption{$M_{6,4}$中$u = (1,1)$且$v = (3,0)$时的$3^{*}$- 容器}
%%%%%\label{fig:example7_mesh}
%%%%%\vspace{-10pt}
%%%%%\end{figure}
%
%其他的情形和定理\ref{thm_hamiltoianPath_4}中的情形1.1类似，因此不再叙述。
%接下来，令$a_{1}=(m-3,0)$且$a_{2}=(m-3,1)$。
%根据归纳假设, 我们可以得到顶点$u$和顶点$v$之间的三条路径$P_{1}^{'}$，$P_{2}^{'}$和$P_{3}^{'}$，且这三条路径覆盖$Mesh(0:m-3,0:n-1)$中的所有顶点。
%因为$deg_{M_{m-2,n}}(a_{1}) = 2$, 所以$\langle a_{1}, a_{2}\rangle$一定是某条路径中的一部分。
%不失一般性，假设$\langle a_{1}, a_{2}\rangle$是路径$P_{1}^{'}$ 的一部分，且设$\{ x, y\} = \{ a_{1}, a_{2}\}$。
%
%所以，我们可以得到$P_{1}^{'} = \langle u, R_{1}, x, y, R_{2}, v \rangle$（注意$R_{1}$和$R_{2}$是路径$P_{1}^{'}$的一部分。如果$v = y$，那么$R_{2} = \emptyset$。），$P_{2}^{'} = \langle u, R_{3}, v \rangle$ 且$P_{3}^{'} = \langle u, R_{4}, v \rangle$。
%接下来，我们设$Q_{1} = \langle (m-2,0), R(m-1,0:n-1), R(m-2,n-1:1) \rangle$和$Q_{2} = \langle R(m-2,1:n-1), R(m-1,n-1:0), (m-2,0) \rangle$。
%
%所以，我们可以得到$M_{m,n}$中顶点$u$和顶点$v$之间的$3^*$- 容器$\{P_{1}, P_{2}, P_{3}\}$，其中$P_{1} = \langle u, R_{1}, x, Q, y, R_{2}, v \rangle$，$P_{2} = \langle u, R_{3}, v \rangle$，$P_{3} = \langle u, R_{3}, v \rangle$，而$Q$的取值如下所示：
%\begin{align}
%      Q = \left\{ \begin{array}{ll}\notag
%       Q_{1}   \ \ \ \textrm{如果} \ x = a_{1}  \ \textrm{且} y = a_{2} \\
%       Q_{2}   \ \ \ \textrm{如果} \ x = a_{2}  \ \textrm{且} y = a_{1} \\
%    \end{array}\right.
%\end{align}
%
%%%%%如图\ref{fig:example8_mesh}中所示，我们给出了$M_{6,4}$ 中$u = (1,1)$且$v = (3,2)$时的$3^{*}$-容器。
%%%%%\begin{figure}[!htbp]
%%%%%\centering
%%%%%\includegraphics[width=95mm]{example8_mesh.eps}
%%%%%\smallcaption{$M_{6,4}$中$u = (1,1)$且$v = (3,2)$时的$3^{*}$- 容器}
%%%%%\label{fig:example8_mesh}
%%%%%\vspace{-10pt}
%%%%%\end{figure}
%
%%情形1.2. 没有两行或两列在$M_{m,n}$中顶点$u$和顶点$v$的外面。
%%情形1.2. $M_{m,n}$中没有两个相邻的边界列或边界行。
%情形1.2. $\{u_{i}, u_{j}\} \subseteq \{0, 1\}$ 且$\{v_{i},v_{j}\} \subseteq \{m-2, m-1\}$。
%
%%如果没有两行或两列在顶点$u$和顶点$v$的外面，
%%$M_{m,n}$中没有两个相邻的边界列或边界行，
%%我们设$u = (u_{i},u_{j})$且$v = (v_{i},v_{j})$，不失一般性，假设$u_{i} \leq  v_{i}$ 且$u_{j} \leq  v_{j}$。
%此情形中$u$一定位于$M_{m,n}$中最上面两行且$v$一定位于$M_{m,n}$ 中最下面两行。
%所以，我们可以将$M_{m,n}$分割成$M_{m-2,n}$和$M_{2,n}$两部分，使得$u \in V(M_{m-2,n})$且$v \in V(M_{2,n})$。
%
%如果$v_{i} = m-1$，那么令$a = (m-3,v_{j})$，$b_{1} = (m-3,v_{j}-1)$，$b_{2} = (m-4,v_{j})$和$b_{3} = (m-3,v_{j}+1)$。
%根据归纳假设，我们可以得到$M_{m-2,n}$中顶点$u$ 和顶点$a$ 之间的三条路径$P_{1}^{'}$，$P_{2}^{'}$和$P_{3}^{'}$，且这三条路径覆盖$M_{m-2,n}$中的所有顶点。
%
%不失一般性，我们设$P_{i}^{'} = \langle u, R_{i}, b_{i}, a \rangle$，其中$1 \leq  i \leq  3$。
%所以，我们可以得到$M_{m,n}$中顶点$u$和顶点$v$之间的$3^*$- 容器$\{ P_{1}, P_{2}, P_{3}\}$ 如下所示：
%\begin{align}
%       \left\{ \begin{array}{ll}\notag
%       P_{1}=\langle u, R_{1}, b_{1}, R(m-2,v_{j}-1:0), R(m-1,0:v_{j}-1), v \rangle\\
%       P_{2}=\langle u, R_{2}, b_{2}, a, (m-2,v_{j}), v \rangle\\
%       P_{3}=\langle u, R_{3}, b_{3}, R(m-2,v_{j}+1:n-1), R(m-1,n-1:v_{j}+1), v \rangle\\
%    \end{array}\right.
%\end{align}
%
%如果$v_{i} = m-2$且$v_{j} \leq  n-3$，那么令$a = (m-3,v_{j}+1)$，$b_{1} = (m-3,v_{j})$，$b_{2} = (m-4,v_{j}+1)$和$b_{3} = (m-3,v_{j}+2)$。
%根据归纳假设，我们可以得到$M_{m-2,n}$中顶点$u$ 和顶点$a$ 之间的三条路径$P_{1}^{'}$，$P_{2}^{'}$和$P_{3}^{'}$，这三条路径覆盖$M_{m-2,n}$中的所有顶点。
%不失一般性，我们设$P_{i}^{'} = \langle u, R_{i}, b_{i}, a \rangle$，其中$1 \leq  i \leq  3$。
%所以，我们可以得到$M_{m,n}$中顶点$u$和顶点$v$之间的$3^*$- 容器$\{ P_{1}, P_{2}, P_{3}\}$ 如下所示：
%\begin{align}
%       \left\{ \begin{array}{ll}\notag
%       P_{1}=\langle u, R_{1}, b_{1}, v \rangle\\
%       P_{2}=\langle u, R_{2}, b_{2}, a, (m-2,v_{j}+1), v \rangle\\
%       P_{3}=\langle u, R_{3}, b_{3}, R(m-2,v_{j}+2:n-1), R(m-1,n-1:0), \\ \quad \quad \quad R(m-2,0:v_{j}-1), v \rangle\\
%    \end{array}\right.
%\end{align}
%
%如果$v_{i} = m-2$且$v_{j} = n-1$，那么令$a = (m-3,v_{j}-1)$，$b_{1} = (m-3,v_{j}-2)$，$b_{2} = (m-4,v_{j}-1)$ 和 $b_{3} = (m-3,v_{j})$。
%根据归纳假设，我们可以得到$M_{m-2,n}$中顶点$u$ 和顶点$a$ 之间的三条路径$P_{1}^{'}$，$P_{2}^{'}$和$P_{3}^{'}$，这三条路径覆盖$M_{m-2,n}$中的所有顶点。
%不失一般性，我们设$P_{i}^{'} = \langle u, R_{i}, b_{i}, a \rangle$，其中$1 \leq  i \leq  3$。
%所以，我们可以得到$M_{m,n}$中顶点$u$和顶点$v$之间的$3^*$- 容器$\{ P_{1}, P_{2}, P_{3}\}$ 如下所示：
%\begin{align}
%       \left\{ \begin{array}{ll}\notag
%       P_{1}=\langle u, R_{1}, b_{1}, R(m-2,v_{j}-2:0), R(m-1,0:v_{j}), v \rangle\\
%       P_{2}=\langle u, R_{2}, b_{2}, a, (m-2,v_{j}-1), v \rangle\\
%       P_{3}=\langle u, R_{3}, b_{3}, v \rangle\\
%    \end{array}\right.
%\end{align}
%
%%%%%如图\ref{fig:example9_mesh}中所示，我们给出了$M_{6,4}$ 中$u = (1,1)$且$v = (4,1)$时的$3^{*}$-容器。
%%%%%
%
%情形2. $n$是奇数。
%当$m = 4$且$n = 5$时，根据顶点$u$和顶点$v$的不同位置分布, 有21 种情形。
%这21种情形中顶点$u$和$v$之间的$3^*$-容器$\{ P_{1}, P_{2}, P_{3}\}$如图\ref{fig:3-pathIn4by5} 所示。
%我们使用$M_{4,5}$作为归纳基础，假设$M_{m-2,n-2}$中任意两个不同部的顶点之间存在一个$3^{*}$-容器。
%接下来，我们只需证明$M_{m,n}$中任意两个不同部的顶点之间存在一个$3^{*}$-容器即可，其中$ m \geq 6$且$ n \geq 7$。
%证明过程和情形1中类似，此处不作重复叙述。
%\end{proof}
%%%然而，和情形1中一样，图\ref{fig:counter_example2}所示的三种情形也不能通过归纳基础得到。
%%%对于这三种情形，分成以下三种情形讨论。
%\begin{figure}[!htbp]
%\centering
%\includegraphics[width=120mm]{3-pathIn4by5.eps}
%\smallcaption{$M_{4,5}$中顶点$u$和顶点$v$之间的$3^*$-容器}
%\label{fig:3-pathIn4by5}
%\end{figure}

%%%%\begin{figure}[!htbp]
%%%%\centering
%%%%\includegraphics[width=90mm]{example9_mesh.eps}
%%%%\smallcaption{$M_{6,4}$中$u = (1,1)$且$v = (4,1)$时的$3^{*}$- 容器}
%%%%\label{fig:example9_mesh}
%%%%\vspace{-10pt}
%%%%\end{figure}

%%%%\begin{figure}[!htbp]
%%%%\centering
%%%%\includegraphics[width=95mm]{3-pathIn4by5-d(u,v)=1.eps}
%%%%\smallcaption{$M_{4,5}$中顶点$u$和顶点$v$之间距离为1时的$3^*$-容器}
%%%%\label{fig:3-pathIn4by5-d(u,v)=1}
%%%%\vspace{-10pt}
%%%%\end{figure}

%%%%\begin{figure}[!htbp]
%%%%\centering
%%%%\includegraphics[width=120mm]{3-pathIn4by5-d(u,v)=3.eps}
%%%%\smallcaption{$M_{4,5}$中顶点$u$和顶点$v$之间距离为3时的$3^*$-容器}
%%%%\label{fig:3-pathIn4by5-d(u,v)=3}
%%%%\vspace{-10pt}
%%%%\end{figure}

%%%%\begin{figure}[!htbp]
%%%%\centering
%%%%\includegraphics[width=120mm]{3-pathIn4by5-d(u,v)=5.eps}
%%%%\smallcaption{$M_{4,5}$中顶点$u$和顶点$v$之间距离为5时的$3^*$-容器}
%%%%\label{fig:3-pathIn4by5-d(u,v)=5}
%%%%\vspace{-10pt}
%%%%\end{figure}


%%\begin{figure}
%%\centering
%%\includegraphics[width=\imgsize\textwidth]{counter_example2}
%%\smallcaption{情形2中无法通过归纳假设得到的三种情形。}
%%\label{fig:counter_example2}
%%\end{figure}

%%\iffalse
%%情形2.1：图\ref{fig:counter_example2}$(a)$中$M_{4,n}$的顶点$u$ 和顶点$v$的$3^*$容器：$\{ P_{1}, P_{2}, P_{3}\}$，如下所示，其中$u =(0,2)$，$v = (3,n-3)$且$n \geq 7$。

%%\begin{align}
%%       \left\{ \begin{array}{ll}\notag
%%       P_{1}=\langle u, Q(0:3,1:0), R(3,2:n-4), v \rangle\\
%%       P_{2}=\langle u, R(0,3:n-3), Q(0:3,n-2:n-1), v \rangle\\
%%       %P_{2}=\langle u, R(0,3:n-1), R(1,n-1:n-2), R(2,n-2:n-1), R(3,n-1:n-2), v \rangle\\
%%       P_{3}=\langle u, Q(1:2,2:n-4), (1,n-3), (2,n-3), v \rangle\\
%%       \end{array}\right.
%%\end{align}

%%情形2.2：图\ref{fig:counter_example2}$(b)$中$M_{m,5}$的顶点$u$ 和顶点$v$的$3^*$容器：$\{ P_{1}, P_{2}, P_{3}\}$。
%%如果$m = 6$，$u = (2,4)$和$v = (3,0)$，$\{ P_{1}, P_{2}, P_{3}\}$如下所示：
%%\begin{align}
%%       \left\{ \begin{array}{ll}\notag
%%       P_{1}=\langle u, (1,4), R(0,4:0), (1,0), (2,0), v \rangle\\
%%       P_{2}=\langle u, (3,4), (4,4), R(5,4:0), (4,0), v \rangle\\
%%       P_{3}=\langle u, (2,3), R(1,3:1), (2,1), (2,2), (3,2), (3,3), R(4,3:1), (3,1), v \rangle\\
%%       %P_{3}=\langle u, (2,3), (1,3), (1,2), (1,1), (2,1), (2,2), (3,2), (3,3), (4,3), (4,2), \\ \quad \quad \quad (4,1), (3,1), v \rangle\\
%%       \end{array}\right.
%%\end{align}

%%如果$m \geq 8$，$u = (2,4)$和$v = (m-3,0)$，$\{ P_{1}, P_{2}, P_{3}\}$如下所示：
%%\begin{align}
%%       \left\{ \begin{array}{ll}\notag
%%       P_{1}=\langle u, (1,4), R(0,4:0), (1,0), (2,0), Q(3:m-4,0:1), v \rangle\\
%%       P_{2}=\langle u, Q(3:m-4,4:3), R(m-3:m-1,4), R(m-1,3:0), (m-2,0), v \rangle\\
%%       P_{3}=\langle u, (2,3), R(1,3:1), (2,1), R(2:m-3,2), (m-3,3), R(m-2,3:1), \\ \quad \quad \quad (m-3,1), v \rangle\\
%%       \end{array}\right.
%%\end{align}

%%情形2.3：图\ref{fig:counter_example2}$(c)$中$M_{m,5}$的顶点$u$ 和顶点$v$的$3^*$容器：$\{ P_{1}, P_{2}, P_{3}\}$。
%%如果$m = 6$，$u = (2,0)$和$v = (3,0)$，$\{ P_{1}, P_{2}, P_{3}\}$如下所示：
%%\begin{align}
%%       \left\{ \begin{array}{ll}\notag
%%       P_{1}=\langle u, v \rangle\\
%%       P_{2}=\langle u, (1,0), R(0,0:4), R(1:5,4), R(5,3:0), (4,0), v \rangle\\
%%       P_{3}=\langle u, (2,1), R(1,1:3), (2,3), (2,2), (3,2), (3,3), R(4,3:1), (3,1), v \rangle\\
%%       \end{array}\right.
%%\end{align}

%%如果$m \geq 8$，$u = (2,0)$和$v = (m-3,0)$，$\{ P_{1}, P_{2}, P_{3}\}$如下所示：
%%\begin{align}
%%       \left\{ \begin{array}{ll}\notag
%%       P_{1}=\langle u, Q(3:m-4,0:1), v \rangle\\
%%       %P_{1}=\langle u, (3,0), (3,1), (4,1), (4,0), \ldots, (m-5,0), (m-5,1), (m-4,1), \\ \quad \quad \quad (m-4,0), v \rangle\\
%%       %P_{2}=\langle u, (1,0), R(0,0:4), R(1:2,4), R(3,4:3), R(4,3:4), \ldots, \\ \quad \quad \quad R(m-5,4:3), R(m-4,3:4), R(m-3:m-1,4), R(m-1,3:0), \\ \quad \quad \quad (m-2,0), v \rangle\\
%%       P_{2}=\langle u, (1,0), R(0,0:4), R(1:2,4), Q(3:m-4,4:3), R(m-3:m-1,4), \\ \quad \quad \quad R(m-1,3:0), (m-2,0), v \rangle\\
%%       P_{3}=\langle u, (2,1), R(1,1:3), (2,3), R(2:m-3,2), (m-3,3), R(m-2,3:1), \\ \quad \quad \quad (m-3,1), v \rangle\\
%%       \end{array}\right.
%%\end{align}
%%\fi


%\begin{lem}
%\label{lem_hamiltoianPath_6}
%如果$m$或$n$是偶数，那么$M_{m,n}$是哈密顿图。
%\end{lem}
%
%\begin{proof}
%不失一般性，假设$m = 2t$，其中$t \geq 1$。
%我们设$P = R(m-1:1,0)$，$P_{2i} = R(2i,1:n-1)$，$P_{2i+1} = R(2i+1,n-1:1)$，其中$0 \leq  i \leq  t-1$。
%那么，$\langle (0, 0), P_0, P_1, P_2, \ldots, P_{2t-1}, P,$
%$(0, 0) \rangle$组成$M_{m,n}$中的一个哈密顿圈，所以$M_{m,n}$是哈密顿图。
%\end{proof}
%
%\begin{thm}
%\label{thm_hamiltoianPath_7}
%对于任意的偶数$m$和整数$n$，有$s\kappa^{L}(M_{m,n})=3$，其中$\min \{m, n\} \geq 4$。
%\end{thm}
%
%\begin{proof}
%根据引理\ref{lem_hamiltoianPath_1}、引理\ref{lem_hamiltoianPath_5}和引理\ref{lem_hamiltoianPath_6}，我们容易推出$M_{m,n}$ 是增强$3^*$-交织的。
%接下来，我们要证明$M_{m,n}$不是增强$4^*$-交织的。
%令$u = (1,1)$和$v = (2,1)$，假设顶点$u$和顶点$v$之间的$4^{*}$容器是$\{ P_{1}, P_{2}, P_{3}, P_{4}\}$。
%因为$N_{M_{m,n}}(u) = \{ (0,1),(1,0),(2,1),(1,2)\}$和$N_{M_{m,n}}((0,\\0)) = \{ (0,1),(1,0)\}$, $(0,0) \notin \bigcup_{i=1}^{4} V(P_{i})$。
%所以，$u$和$v$之间之间没有$4^{*}$-容器。
%故$s\kappa^{L}(M_{m,n})=3$。
%\end{proof}
%
%%%接下来证明本章的第四个结果。
%
%\begin{thm}
%\label{lem_hamiltoianPath_8}
%假设$u$和$v$是$M_{m,n}$中任意两个不同部的顶点，如果$u \notin \{ (1,1), (1,n-2), (m-2,1), (m-2,n-2)\}$且$v \notin\{ (1,1), (1,n-2), (m-2,1), (m-2,n-2)\}$，那么$u$ 和$v$之间存在一个$4^{*}$- 容器，其中$m$ 是偶数且$\min \{m, n\} \geq 6$。
%\end{thm}
%
%\begin{proof}
%不失一般性，假设$u \in A_{m,n}$且$v \in B_{m,n}$。
%我们将$M_{m,n}$中的$(1,1)$，$(1,n-2)$，$(m-2,1)$和$(m-2,n-2)$四个顶点称作坏点。
%根据$n$的奇偶性，分为以下两种情形讨论。
%
%情形1. $n$是偶数。
%当$m = 6$和$n = 6$时，根据顶点$u$和顶点$v$的不同位置分布，有6种$M_{6,6}$情形。
%这六种情形中顶点$u$和顶点$v$之间的$4^*$-容器$\{ P_{1}, P_{2}, P_{3}, P_{4}\}$如图\ref{fig:4-pathIn6by6}所示。
%\begin{figure}[!htbp]
%\centering
%\includegraphics[width=95mm]{4-pathIn6by6.eps}
%\smallcaption{$M_{6,6}$中顶点$u$和顶点$v$之间的$4^*$-容器}
%\label{fig:4-pathIn6by6}
%\vspace{-10pt}
%\end{figure}
%
%%我们原打算像前文所述一样通过判断有没有两行或两列在顶点$u$ 和顶点$v$的外面，从而分成两种情形证明。
%我们首先像前文所述一样判断$u$和$v$是否在$M_{m,n}$中的最上面两行，或最下面两行，或最左边两列，或最右边两列。
%但是如图\ref{fig:counter_example3}所示，当$u = (1,3)$且$v = (1,n-4)$ 时，$u$和$v$不在$M_{6,n}$中的最左边两列和最右边两列，其中$n \geq 8$。
%我们用最右边两列举例说明。
%显而易见，在由最左面$n - 2$列顶点构成的$M_{6,n-2}$中，$v$ 是坏点且顶点$u$和顶点$v$之间是没有$4^*$-容器的。
%我们把这样的两列称作虚假列。
%同样地，最左面两列也是虚假列。
%%因为我们讨论的是$m \geq 6$的情形，所以也不能考虑存在两行在顶点$u$和顶点$v$的外面。
%所以，$M_{6,n}$中的这种情形是无法从归纳基础得到的，此情形中的顶点$u$和顶点$v$之间的$4^*$- 容器$\{ P_{1}, P_{2}, P_{3}, P_{4}\}$ 分为以下两种情形。
%\begin{figure}[!htbp]
%\centering
%\includegraphics[width=65mm]{counter_example3.eps}
%\smallcaption{情形1中不能由归纳基础得到的$M_{6,n}$}
%\label{fig:counter_example3}
%\end{figure}
%
%如果$n = 8$，$\{ P_{1}, P_{2}, P_{3}, P_{4}\}$ 如下所示：
%\begin{align}
%       \left\{ \begin{array}{ll}\notag
%       P_{1}=\langle u, R(1:0,2), Q(0:5,1:0), R(5,2:5), Q(5:0,6:7), \\ \quad \quad \quad R(0:1,5), v \rangle\\
%       P_{2}=\langle u, v \rangle\\
%       P_{3}=\langle u, R(0,3:4), v \rangle\\
%       P_{4}=\langle u, (2,3), R(2:4,2), R(4:3,3), R(3:4,4), R(4:2,5), (2,4), v \rangle\\
%       \end{array}\right.
%\end{align}
%
%如果$n \geq 10$，$\{ P_{1}, P_{2}, P_{3}, P_{4}\}$如下所示：
%\begin{align}
%       \left\{ \begin{array}{ll}\notag
%       P_{1}=\langle u, R(1:0,2), Q(0:5,1:0), R(5,2:n-3), Q(5:0,n-2:n-1), \\ \quad \quad \quad R(0:1,n-3), v \rangle\\
%       P_{2}=\langle u, Q(1:2,4:n-5), v \rangle\\
%       P_{3}=\langle u, R(0,3:n-4), v \rangle\\
%       P_{4}=\langle u, (2,3), R(2:4,2), R(4:3,3), Q(3:4,4:n-5), R(3:4,n-4), \\ \quad \quad \quad R(4:2,n-3), (2,n-4), v \rangle\\
%       \end{array}\right.
%\end{align}
%
%我们设$u = (u_{i},u_{j})$和$v = (v_{i},v_{j})$。
%不失一般性，假设$u_{i} \leq  v_{i}$且$u_{j} \leq  v_{j}$。
%根据对称性，我们可以通过旋转$M_{t,s}$得到$M_{s,t}$。
%假设当$ m \geq 8$且$ n \geq 8$时，引理对$M_{m-2,n-2}$成立。
%接下来，我们需要证明引理对$M_{m,n}$也成立。
%%%根据有没有两行或两列在$M_{m,n}$中顶点$u$和顶点$v$的外面，分成两种情形证明。
%%%根据$M_{m,n}$中没有两个相邻的边界列或边界行，分成两种情形讨论。
%根据$u$和$v$的位置分布情况，分为以下两种情形讨论。
%
%%情形1.1. 没有两行或两列在$M_{m,n}$中顶点$u$和顶点$v$的外面。
%%情形1.1. $M_{m,n}$中没有两个相邻的边界列或边界行。
%情形1.1. $\{u_{i}, u_{j}\} \subseteq \{0, 1\}$ 且$\{v_{i},v_{j}\} \subseteq \{m-2, m-1\}$。
%
%
%此种情形中顶点$v$位于$M_{m,n}$中的最下面两行，即$v_{i} = m-2$。
%令$v^{'} = (m-4,v_{j})$，根据归纳假设，我们可以得到顶点$u$ 和顶点$v^{'}$之间的四条不相交路径$P_{1}^{'}$，$P_{2}^{'}$， $P_{3}^{'}$ 和$P_{4}^{'}$，且这四条路径覆盖$Mesh(0:m-3,0:n-1)$ 的顶点。
%如果我们设$P_{1}^{'} = \langle u, R_{1}, (m-5,v_{j}), v^{'} \rangle$，$P_{2}^{'} = \langle u, R_{2}, (m-4,v_{j}+1), v^{'} \rangle$，$P_{3}^{'} = \langle u, R_{3}, (m-3,v_{j}-2),(m-3,v_{j}-1), (m-4,v_{j}-1), v^{'} \rangle$ 和$P_{4}^{'} = \langle u, R_{4}, (m-3,v_{j}+2), (m-3,v_{j}+1), (m-3,v_{j}), v^{'} \rangle$，
%那么$M_{m,n}$中顶点$u$和顶点$v$之间的$4^*$-容器$\{ P_{1}, P_{2}, P_{3}, P_{4}\}$如下所示：
%\begin{align}
%       \left\{ \begin{array}{ll}\notag
%       P_{1}=\langle u, R_{1}, (m-5,v_{j}), v^{'}, R(m-4:m-2,v_{j}-1), v \rangle\\
%       P_{2}=\langle u, R_{2}, (m-4,v_{j}+1), R(m-3,v_{j}+1:v_{j}), v \rangle\\
%       P_{3}=\langle u, R_{3}, (m-3,v_{j}-2), R(m-2,v_{j}-2:0), R(m-1,0:v_{j}), v \rangle\\
%       P_{4}=\langle u, R_{4}, (m-3,v_{j}+2), R(m-2,v_{j}+2:n-1), R(m-1,n-1:v_{j}+1),\\ \quad \quad \quad (m-2,v_{j}+1), v \rangle\\
%       \end{array}\right.
%\end{align}
%
%如果我们设$P_{1}^{'} = \langle u, R_{1}, (m-5,v_{j}), v^{'} \rangle$，$P_{2}^{'} = \langle u, R_{2}, (m-4,v_{j}-1), v^{'} \rangle$，$P_{3}^{'} = \langle u, R_{3}, (m-3,v_{j}-2),(m-3,v_{j}-1), (m-3,v_{j}), v^{'} \rangle$和$P_{4}^{'} = \langle u, R_{4}, (m-3,v_{j}+2), (m-3,v_{j}+1), (m-4,v_{j}+1), v^{'} \rangle$，
%那么$M_{m,n}$中顶点$u$和顶点$v$之间的$4^*$-容器$\{ P_{1}, P_{2}, P_{3}, P_{4}\}$如下所示：
%\begin{align}
%       \left\{ \begin{array}{ll}\notag
%       P_{1}=\langle u, R_{1}, (m-5,v_{j}), v^{'}, R(m-4:m-2,v_{j}+1), v \rangle\\
%       P_{2}=\langle u, R_{2}, (m-4,v_{j}-1), R(m-3,v_{j}-1:v_{j}), v \rangle\\
%       P_{3}=\langle u, R_{3}, (m-3,v_{j}-2), R(m-2,v_{j}-2:0), R(m-1,0:v_{j}-1), (m-2,v_{j}-1), v \rangle\\
%       P_{4}=\langle u, R_{4}, (m-3,v_{j}+2), R(m-2,v_{j}+2:n-1), R(m-1,n-1:v_{j}),\\ \quad \quad \quad R(m-1,n-1:v_{j}), v \rangle\\
%       \end{array}\right.
%\end{align}


%%%%如图\ref{fig:example10_mesh}中所示，我们给出了$M_{8,6}$ 中当$u = (1,3)$且$v = (6,3)$时的$4^{*}$-容器。
%%%%\begin{figure}[!htbp]
%%%%\centering
%%%%\includegraphics[width=100mm]{example10_mesh.eps}
%%%%\smallcaption{$M_{8,6}$中$u = (1,3)$且$v = (6,3)$时的$4^{*}$- 容器}
%%%%\label{fig:example10_mesh}
%%%%\vspace{-10pt}
%%%%\end{figure}

%情形1.2. 有两行或两列在$M_{m,n}$中顶点$u$和顶点$v$的外面。
%情形1.2. $M_{m,n}$中有两个相邻的边界列或边界行。
%情形1.2. $u_{j} \notin \{0, 1\}$且$v_{j} \notin \{0, 1\}$，或$u_{j} \notin \{n-2, n-1\}$ 且$v_{j} \notin \{n-2, n-1\}$，或$u_{i} \notin \{0, 1\}$ 且$v_{i} \notin \{0, 1\}$，或$u_{i} \notin \{m-2, m-1\}$且$v_{i} \notin \{m-2, m-1\}$。
%不失一般性，假设$u_{i} \notin \{m-2, m-1\}$ 且$v_{i} \notin \{m-2, m-1\}$。
%即$\{ u,v\} \cap \{ (x,y) \mid m-2 \leq  x \leq  m-1 $ 且 $0 \leq  y \leq  n-1 \}= \emptyset $。
%
%如果$deg_{M_{m-2,n}}(v) = 3$，即在$M_{m,n}$中$v_{i} = m-3$，我们从$M_{m,n}$中的顶点$(m-4,v_{j}+1)$和$(m-4,v_{j}-1)$中选取一个作为$v^{'}$，
%使得$deg_{M_{m-2,n}}(v^{'}) = 4$且$v^{'}$不是$M_{m-2,n}$ 中的坏点，其中$M_{m-2,n}$是由最上面的$m-2$行构成的。
%不失一般性，在$M_{m,n}$中设$v^{'} = (m-4,v_{j}+1)$。
%
%根据归纳假设，我们可以得到顶点$u$和顶点$v^{'}$ 之间的四条不相交路径$P_{1}^{'}$，$P_{2}^{'}$，$P_{3}^{'}$和$P_{4}^{'}$，且这四条路径覆盖了$Mesh(0:m-3,0:n-1)$ 中的所有顶点。
%如果我们设$P_{1}^{'} = \langle u, R_{1}, (m-5,v_{j}+1), v^{'} \rangle$，$P_{2}^{'} = \langle u, R_{2}, (m-4,v_{j}+2), v^{'} \rangle$，$P_{3}^{'} = \langle u, R_{3}, (m-3,v_{j}-1), v, (m-4,v_{j}), v^{'} \rangle$和$P_{4}^{'} = \langle u, R_{4}, (m-3,v_{j}+3), (m-3,v_{j}+2),(m-3,v_{j}+1), v^{'} \rangle$，
%那么$M_{m,n}$中顶点$u$和顶点$v$之间的$4^*$-容器$\{ P_{1}, P_{2}, P_{3}, P_{4}\}$如下所示：
%\begin{align}
%       \left\{ \begin{array}{ll}\notag
%       P_{1}=\langle u, R_{1}, (m-5,v_{j}+1), v^{'}, (m-4,v_{j}), v \rangle\\
%       P_{2}=\langle u, R_{2}, (m-4,v_{j}+2), R(m-3,v_{j}+2:v_{j}+1), v \rangle\\
%       P_{3}=\langle u, R_{3}, (m-3,v_{j}-1), v \rangle\\
%       P_{4}=\langle u, R_{4}, (m-3,v_{j}+3), R(m-2,v_{j}+3:n-1), R(m-1,n-1:v_{j}+2),\\ \quad \quad \quad R(m-2,v_{j}+2:v_{j}+1), R(m-1,v_{j}+1:0), R(m-2,0:v_{j}), v \rangle\\
%       \end{array}\right.
%\end{align}
%
%如果我们设$P_{1}^{'} = \langle u, R_{1}, (m-5,v_{j}+1), v^{'} \rangle$，$P_{2}^{'} = \langle u, R_{2}, (m-4,v_{j}), v^{'} \rangle$，$P_{3}^{'} = \langle u, R_{3}, (m-3,v_{j}-1), v, (m-3,v_{j}+1), v^{'} \rangle$ 和$P_{4}^{'} = \langle u, R_{4}, (m-3,v_{j}+3), (m-3,v_{j}+2),(m-2,v_{j}+2), v^{'} \rangle$，那么$M_{m,n}$ 中顶点$u$和顶点$v$之间的$4^*$-容器$\{ P_{1}, P_{2}, P_{3}, P_{4}\}$如下所示：
%\begin{align}
%       \left\{ \begin{array}{ll}\notag
%       P_{1}=\langle u, R_{1}, (m-5,v_{j}+1), v^{'}, (m-4,v_{j}+2), R(m-3,v_{j}+2:v_{j}+1), v \rangle\\
%       P_{2}=\langle u, R_{2}, (m-4,v_{j}), v \rangle\\
%       P_{3}=\langle u, R_{3}, (m-3,v_{j}-1), v \rangle\\
%       P_{4}=\langle u, R_{4}, (m-3,v_{j}+3), R(m-2,v_{j}+3:n-1), R(m-1,n-1:v_{j}+2),\\ \quad \quad \quad R(m-2,v_{j}+2:v_{j}+1), R(m-1,v_{j}+1:0), R(m-2,0:v_{j}), v \rangle\\
%       \end{array}\right.
%\end{align}
%
%
%%%%%如图\ref{fig:example11_mesh}中所示，我们给出了$M_{8,6}$ 中当$u = (1,3)$且$v = (5,2)$ 时的$4^{*}$-容器。
%%%%%
%%%%%\begin{figure}[!htbp]
%%%%%\centering
%%%%%\includegraphics[width=100mm]{example11_mesh.eps}
%%%%%\smallcaption{$M_{8,6}$中$u = (1,3)$且$v = (5,2)$时的$4^{*}$- 容器}
%%%%%\label{fig:example11_mesh}
%%%%%\vspace{-10pt}
%%%%%\end{figure}
%
%如果$deg_{M_{m-2,n}}(v) = 4$且$v$并不是$M_{m-2,n}$中的坏点，其中$M_{m-2,n}$是由最上面的$m-2$行构成。
%这种情形和定理\ref{thm_hamiltoianPath_4}中情形1.1类似，此处不作重复叙述。
%如果$v$是由最上面$m - 2$行顶点构成的$M_{m-2,n}$ 中的坏点，不失一般性，假设$v$是$M_{m,n}$ 中的$(m-4,1)$。
%接下来，我们考虑最上面两行，如果$u$是由最下面的$m - 2$行顶点构成的$M_{m-2,n}$中的坏点, 我们设$u = (3,1)$。
%如果$n \geq 8$, 我们就可以找到除$u$和$v$所在列外的两列且它们不是虚假列。
%$n = 6$的情形是前文所述的特例。
%
%情形2. $n$是奇数。
%当$m = 6$和$n = 7$时，根据顶点$u$和顶点$v$的不同位置分布, 有21 种$M_{6,7}$情形。
%$M_{6,7}$中顶点$u$和顶点$v$之间的$4^*$-容器如图\ref{fig:4-pathIn6by7-d(u,v)=1}，图\ref{fig:4-pathIn6by7-d(u,v)=3} 和图\ref{fig:4-pathIn6by7-d(u,v)=5} 所示。
%
%%%\begin{figure}
%%%\centering
%%%\includegraphics[width=120mm]{4-pathIn6by7-1}
%%%\smallcaption{$M_{6,7}$中顶点$u$和顶点$v$之间的$4^*$-容器。}
%%%\label{fig:4-pathIn6by7-1}
%%%\end{figure}
%
%%%\begin{figure}
%%%\centering
%%%\includegraphics[width=120mm]{4-pathIn6by7-2}
%%%\smallcaption{$M_{6,7}$中顶点$u$和顶点$v$之间的$4^*$-容器。}
%%%\label{fig:4-pathIn6by7-2}
%%%\end{figure}
%
%\begin{figure}[!htbp]
%\centering
%\includegraphics[width=130mm]{4-pathIn6by7-d(u,v)=1.eps}
%\smallcaption{$M_{6,7}$中顶点$u$和顶点$v$之间距离为1时的$4^*$- 容器}
%\label{fig:4-pathIn6by7-d(u,v)=1}
%\vspace{-10pt}
%\end{figure}
%
%\begin{figure}[!htbp]
%\centering
%\includegraphics[width=130mm]{4-pathIn6by7-d(u,v)=3.eps}
%\smallcaption{$M_{6,7}$中顶点$u$和顶点$v$之间距离为3时的$4^*$- 容器}
%\label{fig:4-pathIn6by7-d(u,v)=3}
%\vspace{-10pt}
%\end{figure}
%
%\begin{figure}[!htbp]
%\centering
%\includegraphics[width=130mm]{4-pathIn6by7-d(u,v)=5.eps}
%\smallcaption{$M_{6,7}$中顶点$u$和顶点$v$之间距离为5时的$4^*$- 容器}
%\label{fig:4-pathIn6by7-d(u,v)=5}
%\vspace{-10pt}
%\end{figure}
%
%
%然而，如图\ref{fig:counter_example4}所示，有三种情形是无法由归纳基础得到的。
%对于这三种情形，分成以下三种情形讨论。
%
%\begin{figure}[!htbp]
%\centering
%\includegraphics[width=120mm]{counter_example4.eps}
%\smallcaption{情形2中无法由归纳基础得到的三种情形}
%\label{fig:counter_example4}
%\vspace{-10pt}
%\end{figure}
%
%情形2.1. 图\ref{fig:counter_example4}$(a)$中给出了$M_{6,n}$ 的顶点$u$ 和顶点$v$的$4^*$-容器$\{ P_{1}, P_{2}, P_{3}, P_{4}\}$。
%如果$n \geq 9$，$u =(1,3)$和$v = (4,n-4)$，那么$\{ P_{1}, P_{2}, P_{3}, P_{4}\}$如下所示：
%\begin{align}
%       \left\{ \begin{array}{ll}\notag
%       P_{1}=\langle u, R(1:0,2), Q(0:5,1:0), R(5,2:n-4), v \rangle\\
%       P_{2}=\langle u, R(0,3:n-3), Q(0:5,n-2:n-1), R(5:4,n-3), v \rangle\\
%       P_{3}=\langle u, R(2,3:2), Q(3:4,2:n-6), R(3:4,n-5), v \rangle\\
%       P_{4}=\langle u, Q(1:2,4:n-4), R(1:3,n-3), (3,n-4), v \rangle\\
%       \end{array}\right.
%\end{align}
%
%情形2.2. 图\ref{fig:counter_example4}$(b)$中给出了$M_{m,7}$ 的顶点$u$ 和顶点$v$的$4^*$-容器$\{ P_{1}, P_{2}, P_{3}, P_{4}\}$。
%如果$m = 8$，$u =(3,1)$和$v = (4,1)$，那么$\{ P_{1}, P_{2}, P_{3}, P_{4}\}$如下所示：
%\begin{align}
%       \left\{ \begin{array}{ll}\notag
%       P_{1}=\langle u, R(3:4,0), v \rangle\\
%       P_{2}=\langle u, v \rangle\\
%       P_{3}=\langle u, (5,1), R(5:7,0), Q(7:6,1:4), Q(7:0,5:6), Q(0:1,4:1), \\ \quad \quad \quad R(0:2,0), (2,1), v \rangle\\
%       P_{4}=\langle u, R(3:2,2), Q(2:5,3:4), R(5:4,2), v \rangle\\
%       \end{array}\right.
%\end{align}
%
%如果$m \geq 10$，$u =(3,1)$和$v = (m-4,1)$，那么$\{ P_{1}, P_{2}, P_{3}, P_{4}\}$如下所示：
%\begin{align}
%       \left\{ \begin{array}{ll}\notag
%       P_{1}=\langle u, R(3:m-4,0), v \rangle\\
%       P_{2}=\langle u, Q(4:m-5,1:2), v \rangle\\
%       P_{3}=\langle u, (m-3,1), R(m-3:m-1,0), Q(m-1:m-2,1:4), \\ \quad \quad \quad Q(m-1:0,5:6), Q(0:1,4:1), R(0:2,0), (2,1), v \rangle\\
%       P_{4}=\langle u, R(3:2,2), Q(2:m-3,3:4), R(m-3:m-4,2), v \rangle\\
%       \end{array}\right.
%\end{align}
%
%情形2.3. 图\ref{fig:counter_example4}$(c)$中给出了$M_{m,7}$ 的顶点$u$ 和顶点$v$的$4^*$-容器$\{ P_{1}, P_{2}, P_{3}, P_{4}\}$。
%如果$m \geq 8$，$u =(3,1)$和$v = (m-4,5)$，那么$\{ P_{1}, P_{2}, P_{3}, P_{4}\}$如下所示：
%\begin{align}
%       \left\{ \begin{array}{ll}\notag
%       P_{1}=\langle u, Q(4:m-1,1:0), Q(m-1:m-2,2:5), R(m-1:m-4,6), v \rangle\\
%       P_{2}=\langle u, R(3:0,0), Q(0:1,1:4), Q(0:m-5,5:6), v \rangle\\
%       P_{3}=\langle u, Q(3:m-4,2:3), R(m-3,2:5), v \rangle\\
%       P_{4}=\langle u, R(2,1:3), R(2:m-4,4), v \rangle\\
%       \end{array}\right.
%\end{align}
%
%我们用$M_{6,7}$作为归纳基础，假设定理对于$M_{m-2,n-2}$成立，其中$ m \geq 8$且$ n \geq 9$，我们需证明定理对于$M_{m,n}$也成立，证明过程和情形1中类似，此处不做赘述。
%\end{proof}
%
%\section{本章小结}
%本章提出了增强生成连通度和增强生成交织度的具体定义，
%然后给出了$m$行$n$列的$M_{m,n}$的增强生成交织度的结果以及相应的证明，包括以下结论：
%
%（1）假设$u$和$v$是$M_{m,n}$中的任意两个不同顶点，如果$\{u, v\} \subseteq A_{m,n}$，那么$u$ 和$v$之间存在一个$1^{*}$-容器，其中$m$和$n$ 是奇数且$\min \{m, n\} \geq 3$；
%
%（2）假设$u$和$v$是$M_{m,n}$中的任意两个不同顶点，如果$\{u, v\} \subseteq B_{m,n}$，那么$u$ 和$v$之间存在一个$3^{*}$-容器，其中$m$和$n$ 是奇数且$\min \{m, n\} \geq 3$；
%
%（3）$s\kappa^{L}(M_{m,n})=3$，其中$m$是偶数且$\min \{m, n\} \geq 4$；
%
%（4）假设$u$和$v$是$M_{m,n}$中任意两个不同部的顶点，如果$u \notin \{ (1,1), (1,n-2), (m-2,1), (m-2,n-2)\}$且$v \notin\{ (1,1), (1,n-2), (m-2,1), (m-2,n-2)\}$，那么$u$ 和$v$之间存在一个$4^{*}$- 容器，其中$m$ 是偶数且$\min \{m, n\} \geq 6$。
