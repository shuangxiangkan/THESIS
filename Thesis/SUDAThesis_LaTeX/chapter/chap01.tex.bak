 \chapter{绪论}
\label{chap:chap01}


\section{研究背景}

%随着大数据和人工智能时代的来临，数据的规模也呈爆炸式的增长。对数据的有效处理也成为了能否
%有效利用海量数据的关键之一。在这样的需求和背景下，云计算应运而生。云计算（Cloud Computing）是分布式计算的一种，指的是通过网络“云”将巨大的数据计算处理程序分解成无数个小程序，然后，通过多部服务器组成的网络进行处理和分析这些小程序得到结果并返回给用户。云计算的发展将会改变我们的生活、学习和生产方式，而且改变将是颠覆性的，就像当年的工业大革命一样，完全使人们进入了一个数据化和自动化的世界。云计算激发了技术大变革，行业技术竞争的焦点转向了数据中心计算、新型人机交互和智能算法等方面。在这些技术领域，国内的工业界尤其是大型的互连网公司，凭借积累的技术经验和丰厚的资金支持，与国际科技巨头的差距并不是特别大。技术的开源和开放性，为我国迎头赶上乃至实现超越提供了机会。从国家战略层面来说，我们应该建立自己的云计算平台，充分利用云计算这一先进生产力来帮助提升我国的科技和创新能力，并确保国家安全。因此，为了进一步提升我国云计算发展与应用水平，积极抢占信息技术发展的制高点。中国工业和信息化部提出了《云计算发展三年行动计划》，并制定到2019年云计算产业规模达到4300亿元的发展目标
%\upcite{cloudComputing}。
%
%云计算的发展和应用受到多方面的影响，而数据中心网络的性能则是影响云计算能否有效处理海量数据的重要因素之一。随着数据规模的不断扩大，数据中心网络的规模也呈现出指数级的增长。
%腾讯在2019年底的服务器的数量就已经达到100 万台\upcite{tecent}。截止到2020年7月，阿里云在全球22个地域部署了上百个数据中心，服务器的总规模数已经接近200万台。如果把这些服务器堆叠起来，整体高度会超过20个珠穆朗玛峰\upcite{aliyun}。
%至2012 年3 月，亚马逊EC2云基础设施平台的服务器数量已经达到45.4万台\upcite{Amazon-EC2-cloud}。 谷歌在2010 年底所拥有的服务器就已经达到90 多万台，而这个数字在2006年是45万台\upcite{google}。此外，微软的服务器数量每14 个月就要增加一倍，这种增长速度已经超过了摩尔定律\upcite{Microsoft}。在2013 年底，微软的数据中心的服务器数量已经超过100 万台\upcite{Microsoft2}。

随着我国社会信息化的不断发展，数据规模的不断扩大，对海量数据处理的要求也越来越高，这直接或间接地促进了我国高性能计算的发展。高性能计算主要是指从体系结构、并行算法和软件开发等方面研究开发高性能计算机的技术\upcite{Zhang2019HighPerformance}。从一般意义上来说，现在人们常说的并行计算，超级计算和高性能计算是同义词。从战略意义上讲，高性能计算已经是一个国家综合国力的重要体现，在国防安全、科技发展和国民经济建设中具有重要的战略地位，是支撑国力的关键技术之一\upcite{Chen2015HighPerformance}。

20世纪末，随着“曙光”、“银河”、“神威”等一系列国产超级计算机的出现，我国高性能计算能力与美国、日本等发达国家的差距逐渐缩小。进入21世纪，我国的高性能计算得到进一步发展，国防科技大学的“天河二号”超级计算机和无锡的“神威$\cdot$太湖之光”超级计算机长期位于世界超级计算机TOP 500 冠军位置。而且在2016年的全球超级计算机大会上，中国获得了国际高性能计算应用领域的最高奖：戈登$\cdot$贝尔奖\upcite{A-survey-of-communication}。这表明中国的高性能计算的计算能力已经跻身世界一流国家行列。中国科学院计算技术研究所所长李国杰曾经说过，高性能计算机是真正的先进生产力，是最典型的第一生产力\upcite{ZhengHighPerformance}。高性能计算不仅应用于如飞机制造、地震预测和能源勘探等重要的国防工业，而且在民用和商用领域，如金融、服务和生活等也发挥着越来越重要的作用。此外，人工智能特别是深度学习的快速发展，正在改变各行各业的面貌，从健康医疗到交通运输再到自动驾驶汽车，无不受其变革性的影响，而高性能计算的超强算力正在加速这一变革。

%面对规模如此巨大的服务器数量，如何将它们有效地连接起来，使其成为一个性能优良的数据中心网络。是各个企业以及国家所急需解决的问题。
并行计算作为高性能计算的基础，对于高性能计算的表现至关重要。并行计算的基础互连网络为处理器（顶点）之间进行数据通信提供了物理基础，其拓扑结构决定了顶点间的通信效率，是影响并行计算机性能的主要因素之一，因而成为并行计算领域的重要研究方向\upcite{Wangxi}。为了进一步提高并行计算的性能，各种各样的互连网络拓扑结构被相继提出。这些拓扑结构在很大程度上影响着网络的性能，如构造成本、延迟、路由以及可靠性等。最早提出的互连网络拓扑结构包括树、环、总线和完全图等。虽然树、环和总线的结构简单且易于构造，但由于其稳定性不高，当网络中的一些资源（如顶点，链路等）发生故障时，很容易造成整个网络的瘫痪。完全图虽然稳定性较好，因为其每个顶点都和剩余的所有顶点相连，但是在顶点数量规模很大的情况下，链路数量会急剧增大，导致其构造成本过高，不适宜大规模的互连网络。因此，后来许多学者提出了一些成本较低、易于构造且稳定性较好的互连网络拓扑结构，包括超立方体（Hypercube）\upcite{hypercube}、网格（Mesh）
\upcite{mesh}、交叉立方体（Crossed cube）\upcite{crossed-cube}、星图（Star graph）\upcite{star}和广义超立方体（Generalized hypercube）\upcite{Generalized-Hypercube}等。 其中超立方体是这些拓扑结构中比较具有代表性的一类网络，因其具有很多优良的性质如边对称、顶点对称、低顶点度数和正则性等而受到广泛的关注。后来的很多拓扑结构都是基于超立方体改造而提出的。

本文研究的互连网络拓扑结构是由Choudum等人\upcite{Choudum2002}提出的扩展立方体（Augmen-ted cube），该结构是在超立方体的基础上按照一定的规则增加一些边得到的，它不仅保留了超立方体的许多优良的性质，如递归构造性和高对称性等，同时也拥有着超立方体和它的其他变体所不具备的优点，比如，$n$-维扩展立方体的连通度是$2n-1$，几乎是超立方体的两倍，这意味着扩展立方体的容错性能在某些方面远胜过超立方体。同时，扩展立方体还具备超立方体所没有的某些嵌入性质\upcite{journals/cma/LeeTTH09,conf/ispan/HsuLTL09,conf/ispan/HsuCTH04,journals/amc/HsiehS07}。 本文主要对于扩展立方体的容错性和可靠性进行研究，在这之前其他学者对扩展立方体的容错性已经进行了大量的研究工作。Ma等人\upcite{The-super-connectivity-of-augmented-cubes}证明了$n$-维扩展立方体的超连通度（Super connectivity）和超边连通度（Super edge-connectivity）分别为$4n-8$和$4n-4$，将扩展立方体传统的连通度和边连通度\upcite{Choudum2002}（$2n-2$）几乎提高了2 倍。接着Ma等人\upcite{Fault-tolerant-analysis-of-augmented-cubes}又证明了$n$-维扩展立方体的2-额外连通度和2-额外边连通度分别为$6n-17$和$6n-9$。Chang等人\upcite{Conditional-Diagnosability-of-Augmented-Cubes}证明了$n$-维扩展立方体在PMC诊断模型下的条件诊断度为$8n-27$。Hong等人\upcite{HongW2012}证明了$n$-维扩展立方体在MM$^*$诊断模型下的条件诊断度为$6n-17$。这些研究结果再次证明了扩展立方体是可靠性较好的互连网络。
我们将在本文中继续研究扩展立方体的容错性质，其中包括结构连通度，子结构连通度和额外诊断度等性质，并给出容错路由算法和诊断算法。



\section{研究现状及研究意义}

随着互连网络规模的不断扩大，网络中的资源如顶点和链路等会不可避免地发生故障。因此一个互连网络的容错能力是一个网络能正常运行的关键。我们希望可以通过一些指标来评估一个互连网络的容错能力，其中连通度是评价一个网络容错能力最常用的指标之一。
%此外，当网络中的某些资源发生故障时，如果大部分的服务器仍然可以正常工作，如何找到两个无故障服务器之间的无故障路径也是保证网络可以完成特定任务的关键。
此外，如何将故障资源诊断出来，并将其替换为可以正常工作的资源，也是互连网络容错能力的重要体现。接下来，我们将对连通度和诊断这两个方面进行详细阐述。

\subsection{连通度}

为了更好地研究互连网络的性质，我们通常将一个互连网络抽象为一个简单无向图，其中的每个顶点表示一个处理器，每条边表示两个处理器之间的链路。连通度是衡量一个互连网络容错能力的重要指标之一。一个拥有$n$个顶点的图$G$，在删除任意不超过$k-1$（$n>k$）个顶点之后仍然是连通的，且存在$k$ 个顶点，将这$k$个顶点删除后得到的图是不连通的或者平凡的（指仅有一个顶点的图），那么整数$k$ 称为图
$G$的连通度，用$\kappa(G)=k$表示。通常，一个图的连通度越大，这个图所代表的互连网络就越稳定。尽管传统连通度可以在某种程度上反映一个网络的容错能力，但是它有一个明显的缺陷，那就是连通度往往假设一个顶点的所有邻居顶点可能会同时发生故障而导致整个网络变为不连通的或者平凡的，但是，这种情形在现实中发生的概率往往是非常低的。因此，传统的连通度往往不能真实地反映出大规模互连网络在实际运行环境中出现故障的情形。

为了弥补这种缺陷，Harary等人\upcite{Harary1983}提出了条件连通度。条件连通度是指将图$G$变为不连通时，其剩余的所有连通分支仍然具有某种图的性质所需要删除的最少的顶点数。
%是的当网络因为某些顶点发生故障而变为不连通时，对该不连通图中的每个连通分支增加一些限制条件。
基于条件连通度的概念，Latifi等人\upcite{Latifi1994}提出了$g$-限制连通度的概念。
给定一个图$G$和一个非负整数$g$，如果$G$中存在一个顶点集合，当$G$删除这个顶点集合后，该图变为不连通的，剩余的每个连通分支中的每个顶点至少有$g$个邻居顶点，那么我们就称这个集合为
图$G$的$g$-限制顶点割。图$G$的$g$-限制连通度指的是图$G$的所有$g$-限制顶点割的最小基数，记为$\kappa^{g}(G)$。
%一个图$G$的$g$-限制连通度，是使得图$G$变为不连通的或者平凡的，且剩余的每个连通分支中的每个顶点至少有$g$个邻居顶点而所需要删除的最少顶点数，记为$\kappa^{g}(G)$。
%接着，
接着，F$\grave{a}$brega等人\upcite{FABREGA199649}又提出了$g$-额外连通度的概念。给定一个图$G$和一个非负整数$g$，如果$G$中存在一个顶点集合，当$G$删除这个顶点集合后，该图变为不连通的，且每个连通分支所包含的顶点个数大于等于$g+1$，那么我们就称这个集合为
图$G$的$g$-额外顶点割。图$G$的$g$-额外连通度指的是图$G$的所有$g$-额外顶点割的最小基数，记为$\kappa_{g}(G)$。
$g$-额外连通度是超连通度\upcite{Ma2008}的一般化，一个图的超连通度实际上对应的是$\kappa_{1}(G)$。关于条件连通度的更多信息可以参考论文
\cite{YANG2009887,GuoLGuoX,HSIEH201263,YU201386,CHEN20071848,GuoLLeeCW,NING201765,WAN2009264,GuoLQinC,LinL2015,Yang2013,ZHANG2014374,Wang2018336,4335424,Wang201852,Ma2008}。

但是，无论是传统的连通度还是条件连通度，它们都基于这样一种假设：单个顶点发生故障是一个独立的事件。在这种情况下，当网络中的一个顶点发生故障时，这个故障顶点对它周围的顶点是没有任何影响的。然而在实际的运行环境中，当一个顶点发生故障时，它周围的邻接顶点发生故障的概率大大增加，这样就可能在网络中产生一个故障结构。正是基于这样的考虑，Lin等人
\upcite{Lin2016}提出了结构连通度和子结构连通度的概念，并对超立方体的$H$-结构连通度和$H$-子结构连通度进行了研究，其中$H \in \{K_1,K_{1,1},K_{1,2},K_{1,3},C_4\}$（相关定义见第二章）。接着Lin等人\upcite{Lin2020}又证明了类超立方体（Hypercube-like）的$H$-结构连通度和$H$-子结构连通度，其中
$H \in \{K_{1,m},C_4\}, m \geq 1$，使得结构连通度和子结构连通度的结论适用于一类网络，而不是某种具体的网络。Sabir和Meng\upcite{Sabir2018}推广了超立方体中的结果，并进一步研究了折叠超立方体（Folded hypercube）中的结构连通度和子结构连通度。Lv等人\upcite{Lv2018}研究了$k$-元$n$-立方体（$k$-ary $n$-cube network）的$H$-结构连通度和$H$-子结构连通度，其中$H \in \{K_1,K_{1,1},K_{1,2},K_{1,3}\}$。
显然，结构连通度实际上是把故障元素从单个故障顶点扩展到故障结构的形式，其更能反映互连网络中资源发生故障的情形。更多关于结构连通度和子结构连通度的研究可以参考论文
\cite{Huazhong,Dong2018Structur,wang2019structure}。

\subsection{诊断}

随着互连网络规模的扩大，因为运行环境或者人为干扰等其他的原因，网络中的一些顶点会不可避免地发生故障。
因此网络的稳定性是保证网络正常工作的关键之一。为了保证互连网络的正常运行，互连网络应该能够确定这些故障顶点并以无故障顶点来替换这些故障顶点。系统利用自身资源寻找互连网络中故障顶点的过程叫做系统级诊断。
%而一个网络所能确定的最大的故障顶点数叫做这个网络的诊断度。有几种不同的诊断模型已经被提出来，
在系统级的诊断中，PMC模型和MM*模型是使用最广泛的两种。

%下面我们对这两种诊断模型进行说明。
%
%\subsubsection{PMC模型}

Preparata，Metze和Chien\upcite{PMC}提出的PMC模型是基于测试的。PMC模型假设一个顶点可以测试与它相邻的顶点的状态（故障或者无故障）。测试顶点是无故障的，则测试结果才是可靠的，否则是不可靠的。下面的表格\ref{PMCresult}说明不同状态的顶点的测试结果。我们用$u$表示测试顶点，
$v$表示被测试顶点，测试的所有结果的集合叫做症状（Syndrome）。我们用$0$表示$u$测试$v$是无故障的，反之则用$1$表示$u$测试$v$是故障的。

\begin{table}[!htb]
\centering
\smallcaption{PMC模型下不同状态顶点的测试结果} \label{PMCresult}.
%\vspace{+23pt}
{%\small
    \begin{tabular}{|c|c|c|}
\hline
       测试顶点$u$  &被测试顶点$v$  &测试结果\\
\hline
   正常        &正常    &0            \\
   正常        &故障    &1            \\
   故障        &正常    &0或1        \\
   故障        &故障    &0或1          \\

\hline
\end{tabular}
}
\end{table}

%
%\subsubsection{MM*模型}


Maeng和Malek\upcite{MM}提出的MM模型是基于比较的。MM模型下的一个测试顶点$w$向其两个不同的被测试的邻居顶点$u$ 和$v$各发送一个测试任务，然后比较它们的返回信息。不同的测试顶点可以测试相同的两个被测试顶点。比较的结果分为一致的和不一致的。和PMC模型一样，只有在测试顶点是无故障顶点的情况下，测试结果才是可靠的。当测试顶点和两个被测试顶点都是无故障顶点时，测试结果是一致的，记为0，否则记为1。
Sengupta和Dahbura\upcite{MM*}提出的MM$^*$模型是对MM模型的进一步改进，在这个模型中，每个顶点必须测试另外两个相邻的顶点。下面的表格\ref{MM*result}说明了MM*模型下在不同状态的顶点的测试结果。

\begin{table}[!htb]
\centering
\smallcaption{MM*模型下不同状态顶点的测试结果} \label{MM*result}.
%\vspace{+23pt}
{%\small
    \begin{tabular}{|c|c|c|}
\hline
       测试顶点$w$的状态  &被测试顶点$u$和$v$的状态  &测试结果\\
\hline
正常           &都正常    &0            \\
正常           &至少有一个故障    &1            \\
故障           &任意    &0或1        \\


\hline
\end{tabular}
}
\end{table}

%\subsubsection{诊断度}

如果一个网络中发生故障的顶点个数不超过$t$，并且所有故障顶点都能在不更换的情况下被网络识别，
%如果所有故障顶点都能在不更换的情况下被网络识别，且发生故障的顶点个数不超过$t$，
那么这个网络就是$t$-可诊断的。一个网络的诊断度
%，记为$t(G)$，
是网络可诊断出的最多的故障顶点数。但是这种传统的诊断度往往假设某个顶点的所有相邻顶点会同时发生故障。但如前所述，在现实的场景中，这种情况发生的概率是非常小的，而且这种情况下网络的诊断度往往受限于网络的最小顶点度数。为了更真实地反映网络运行的真实场景，Lai 等人\upcite{Conditional-Diagnosability-Measures-for-Large}提出了一种改进的诊断度，称为条件诊断度，它假定任何一个顶点的所有相邻顶点都不会同时发生故障。条件诊断度从更实际的角度反映了网络中顶点发生故障的情形。接着，
Peng等人\upcite{Peng2012}提出了$g$-好邻居条件诊断度。$g$-好邻居条件诊断度定义为在网络中的每个无故障顶点都至少有$g$个无故障的相邻顶点的条件下，网络可诊断出的故障顶点的最大数目，他们给出了$n$-维超立方体在PMC模型下的$g$-好邻居条件诊断度，其中$0 \leq g \leq n-3$。后来，
Zhang和Yang\upcite{The-g-extra-conditional-sequential}又提出了$g$-额外条件诊断度（也称额外诊断度）的概念。额外条件诊断度是网络在每个无故障分支都有大于等于$g+1$个无故障顶点的情况下所能诊断出的最大故障顶点数，他们确定了$n$-维超立方体在PMC模型下的$g$-额外条件诊断度，其中$0 \leq g \leq n-4$。接着，Wang等人\upcite{WangS2017}证明了在PMC和MM$^*$模型下排列群图（Alternating group graph networks）的$2$-额外条件诊断度。Lv等人\upcite{Lv2019}给出了$(n,k)$- 星图（($n,k$)-star network）在MM$^*$ 模型下的$g$-额外条件诊断度，其中$1 \leq g \leq $min$\{\frac{n+k-1}{4},k-2\}$。根据以上的研究结果可以发现，条件诊断度可以诊断的故障顶点数比传统的诊断度要大得多。

%\subsection{容错路由}
%
%容错路由是指当互连网络中存在一定数量的故障顶点时，两个无故障顶点之间仍然可以找到一条无故障的通信路径。


\section{研究内容}
本文的研究内容分为以下两个部分：

一、扩展立方体的结构连通度和子结构连通度

在第三章中，我们求出了扩展立方体的结构连通度和子结构连通度，这里的结构包括二分图，路径和圈。进一步，我们给出了扩展立方体在故障顶点数小于$K_{1,6}$-子结构连通度下的容错路由算法，分析了算法的时间复杂度并且给出了该算法所构造的最大无故障路径长度。最后，我们给出了该容错路由算法与其他算法的模拟实验的结果。

%在第三章中，基于结构连通度和子结构连通度的定义，
%我们求出了扩展立方体的结构连通度和子结构连通度，并给出了相关证明。
%同时， 我们给出了扩展立方体在故障顶点数小于$K_{1,6}$-子结构连通度下的容错路由算法，并给出模拟实验的结果。


二、扩展立方体的额外诊断度及其诊断算法

在第四章中，
%基于额外诊断度的定义，
我们求出了扩展立方体在MM$^*$诊断模型下的$2$-额外诊断度。
进一步，我们给出了当扩展立方体的故障顶点数等于$2$-额外诊断度时的诊断算法，分析了算法的时间复杂度并给出了模拟实验的结果来验证算法的有效性。



\section{文章组织结构}

全文的组织结构如下：

第一章介绍了本课题的研究背景，研究现状，研究内容以及文章的组织结构。

第二章首先介绍了基本定义和符号表示，
然后介绍了扩展立方体的基本定义和后面要用到的一些性质。

第三章证明了扩展立方体的结构连通度及子结构连通度，
并给出了扩展立方体在故障顶点数小于$K_{1,6}$-子结构连通度下的容错路由算法及模拟实验。

第四章证明了扩展立方体在MM$^*$诊断模型下的$2$-额外诊断度，
并给出了扩展立方体在MM$^*$模型下的$2$-额外诊断算法及模拟实验。
%AQ-EXTRA-DIAG，
%并给出了当扩展立方体的故障顶点数为$2$-额外诊断度时的诊断算法及模拟实验。

第五章对本论文所做的工作进行了总结，并对未来的研究工作进行了展望。
%一、不相交路径覆盖问题。
%
%如图\ref{fig:DPC_example}所示，令图$H$是由$V(H) = \{ a, b, c, d, e \}$ 和$E(H) = \{ (a, b), (a, c), (a, d), (a, e), \\(b, c), (b, d), (c, d), (c, e), (d, e) \}$ 组成的。
%根据表\ref{k*-container_of_H1}所示，我们可得$H$的生成连通度是3，即$H$中的任意两个不同顶点之间都存在3条不相交路径且它们覆盖$H$ 中的所有顶点。
%但是如表\ref{k*-container_of_H2}所示，$\{ a, c, d \}$中的任意两个不同顶点之间都存在4条不相交路径且它们覆盖$H$中的所有顶点。
%可以看出传统的生成连通度并不能很好的描述图$H$的性质，因此我们在传统生成连通度和生成交织度的基础上，提出了增强生成连通度和增强生成交织度的定义。
%在第三章中，我们求出了二维网格网络的增强生成交织度，并取得如下研究成果：
%
%1. 假设$u$和$v$是$M_{m,n}$中的任意两个不同顶点，如果$\{u, v\} \subseteq A_{m,n}$，那么$u$ 和$v$之间存在一个$1^{*}$-容器，其中$m$和$n$是奇数且$\min \{m, n\} \geq 3$；
%
%2. 假设$u$和$v$是$M_{m,n}$中的任意两个不同顶点，如果$\{u, v\} \subseteq B_{m,n}$，那么$u$ 和$v$之间存在一个$3^{*}$-容器，其中$m$和$n$是奇数且$\min \{m, n\} \geq 3$；
%
%3. $s\kappa^{L}(M_{m,n})=3$，其中$m$是偶数且$\min \{m, n\} \geq 4$；
%
%4. 假设$u$和$v$是$M_{m,n}$中任意两个不同部的顶点，如果$u \notin \{ (1,1), (1,n-2), (m-2,1), (m-2,n-2)\}$且$v \notin\{ (1,1), (1,n-2), (m-2,1), (m-2,n-2)\}$，那么$u$和$v$之间存在一个$4^{*}$- 容器，其中$m$是偶数且$\min \{m, n\} \geq 6$。
%
%\begin{figure}[!htbp]
%\centering
%\includegraphics[width=40mm]{DPC_example.eps}
%\smallcaption{简单图$H$}
%\label{fig:DPC_example}
%\vspace{-10pt}
%\end{figure}
%
%
%如前文所述，利用不相交路径性质，我们可以将信息分成多份，通过多条不相交路径进行传递，这样既可以增强路由的传输性能，也可以提高其可靠性。
%通过多条不相交路径传递信息时，其中最长路径的长度如果能够尽可能的短，那么信息的传递速度就较快。
%在第四章中，我们讨论二维环绕网络中任意两个不同部的顶点间$4^{*}$- 容器中最长路径长度上限，即二维环绕网络的宽生成直径的上限，结论如下：
%
%$D^{s_{L}}_{\kappa(T_{4m,12t})}(T_{4m,12t}) \leq 16mt+1$，其中$m \geq 2$且$t \geq 1$。
%
%\begin{table}[!htb]
%\centering
%\smallcaption{图$H$中的$1^*$-容器，$2^*$-容器和$3^*$-容器} \label{k*-container_of_H1}.
%{\small
%    \begin{tabular}{|l|l|l|l|}
%    \hline
%     $x$ to $y$ & $1^*$-容器 & $2^*$-容器 & $3^*$-容器 \\
%     \hline
%     a $\rightarrow$ b & $\{ \langle a, e, d, c, b \rangle \}$ & $\{ \langle a, b \rangle, \langle a, e, d, c, b \rangle \}$ & $\{ \langle a, b \rangle, \langle a, c, b \rangle, \langle a, e, d, b \rangle \}$ \\
%     \hline
%     a $\rightarrow$ c & $\{ \langle a, b, d, e, c \rangle \}$ & $\{ \langle a, c \rangle, \langle a, b, d, e, c \rangle \}$ & $\{ \langle a, c \rangle, \langle a, b, c \rangle, \langle a, e, d, c \rangle \}$ \\
%     \hline
%     a $\rightarrow$ d & $\{ \langle a, b, c, e, d \rangle \}$ & $\{ \langle a, d \rangle, \langle a, b, c, e, d \rangle \}$ & $\{ \langle a, d \rangle, \langle a, e, d \rangle, \langle a, b, c, d \rangle \}$ \\
%     \hline
%     a $\rightarrow$ e & $\{ \langle a, b, c, d, e \rangle \}$ & $\{ \langle a, e \rangle, \langle a, b, c, d, e \rangle \}$ & $\{ \langle a, e \rangle, \langle a, d, e \rangle, \langle a, b, c, e \rangle \}$ \\
%     \hline
%     b $\rightarrow$ c & $\{ \langle b, a, e, d, c \rangle \}$ & $\{ \langle b, c \rangle, \langle b, a, e, d, c \rangle \}$ & $\{ \langle b, c \rangle, \langle b, d, c \rangle, \langle b, a, e, c \rangle \}$ \\
%     \hline
%     b $\rightarrow$ d & $\{ \langle b, a, e, c, d \rangle \}$ & $\{ \langle b, d \rangle, \langle b, a, e, c, d \rangle \}$ & $\{ \langle b, d \rangle, \langle b, c, d \rangle, \langle b, a, e, d \rangle \}$ \\
%     \hline
%     b $\rightarrow$ e & $\{ \langle b, a, c, d, e \rangle \}$ & $\{ \langle b, a, e \rangle, \langle b, c, d, e \rangle \}$ & $\{ \langle b, a, e \rangle, \langle b, c, e \rangle, \langle b, d, e \rangle \}$ \\
%     \hline
%     c $\rightarrow$ d & $\{ \langle c, e, a, b, d \rangle \}$ & $\{ \langle c, e, d \rangle, \langle c, a, b, d \rangle \}$ & $\{ \langle c, a, d \rangle, \langle c, b, d \rangle, \langle c, e, d \rangle \}$ \\
%     \hline
%     c $\rightarrow$ e & $\{ \langle c, a, b, d, e \rangle \}$ & $\{ \langle c, e \rangle, \langle c, a, b, d, e \rangle \}$ & $\{ \langle c, e \rangle, \langle c, a, e \rangle, \langle c, b, d, e \rangle \}$ \\
%     \hline
%     d $\rightarrow$ e & $\{ \langle d, b, a, c, e \rangle \}$ & $\{ \langle d, e \rangle, \langle d, b, a, c, e \rangle \}$ & $\{ \langle d, e \rangle, \langle d, c, e \rangle, \langle d, b, a, e \rangle \}$ \\
%     \hline
%    \end{tabular}
%}
%\end{table}
%
%\begin{table}[!htb]
%\centering
%\smallcaption{图$H$中的$4^*$-容器} \label{k*-container_of_H2}.
%{\small
%     \begin{tabular}{|l|l|}
%    \hline
%     $x$ to $y$ & $4^*$-容器\\
%     \hline
%     a $\rightarrow$ b & none \\
%     \hline
%     a $\rightarrow$ c & $\{ \langle a, c \rangle, \langle a, b, c \rangle, \langle a, d, c \rangle, \langle a, e, c \rangle \}$ \\
%     \hline
%     a $\rightarrow$ d & $\{ \langle a, d \rangle, \langle a, b, d \rangle, \langle a, c, d \rangle, \langle a, e, d \rangle \}$ \\
%     \hline
%     a $\rightarrow$ e & none \\
%     \hline
%     b $\rightarrow$ c & none \\
%     \hline
%     b $\rightarrow$ d & none \\
%     \hline
%     b $\rightarrow$ e & none \\
%     \hline
%     c $\rightarrow$ d & $\{ \langle c, d \rangle, \langle c, a, d \rangle, \langle c, b, d \rangle, \langle c, e, d \rangle \}$ \\
%     \hline
%     c $\rightarrow$ e & none \\
%     \hline
%     d $\rightarrow$ e & none \\
%     \hline
%    \end{tabular}
%}
%\end{table}
%
%二、容错最长路径问题。
%
%在互连网络中，顶点发生故障是在所难免的，所以容错性是衡量网络性能的一个重要参数。
%受到Lin等人\upupcite{cklin2016connectivity}提出的两个新的连通度：结构连通度和子结构连通度的启发，我们讨论互连网络中顶点出现大面积故障或某个顶点及其邻
%居顶点发生故障的情况下，任意两个无故障顶点之间的最长无故障路径。
%主要结论如下：
%
%1. 若在$T_{m,n}$中出现一个故障网格$M_{s,t}$，满足$s \leq m-4$且$t \leq n-4$，则对于$T_{m,n}$中的任意两个无故障顶点$u$和$v$，$u$和$v$之间存在一条长度大于等于$mn-st-3$的最长无故障路径，其中$m$ 和$n$均是偶数且$\min \{ m, n\} \geq 6$。
%
%2. 当在$T_{m,n}$中某个顶点及其邻居顶点出现故障时，对于$T_{m,n}$ 中的任意两个无故障顶点$u$ 和$v$，$u$和$v$之间存在一条长度大于等于$mn-10$的最长无故障路径，其中$m$和$n$均是偶数且$\min \{m, n\} \geq 8$。
%
%3. 当在网格网络$M_{m,n}$中出现一个故障网格$M_{s,t}$时，如果满足$ 4 \leq s \leq m-8$，$4 \leq t \leq n-8$和$V(M_{s,t}) \cap \{V(Mesh(0:3,0:n-1))\cup V(Mesh(m-4:m-1,0:n-1))\cup V(Mesh(0:m-1,0:3))\cup V(Mesh(0:m-1,n-4:n-1))\} = \varnothing $，那么对于$M_{m,n}$中的任意两个无故障顶点$u$和$v$，$u$和$v$之间存在一条长度大于等于$mn-st-2$的最长无故障路径，其中$m$，$n$，$s$和$t$ 均是偶数且$\min \{m, n\} \geq 12$。
%
%4. 基于大面积顶点发生故障和某个顶点及其邻居顶点发生故障两种情形给出了环绕网络中的容错最长无故障路径路由算法。
%结果表明，在耗时以及路径长度上都有很好的表现。
%
%
%\iffalse
%如前文所述，$n$维超立方体的(边)连通度是$n$。
%从概率论的角度分析，如果$Q_{n}$中存在$n$个故障顶点，那么$Q_{n}$ 不连通的概率为：$\frac{2^{n}}{\binom{2^{n}}{n}}$。
%当$n$足够大时，一个顶点的所有邻接点同时故障的情况几乎是不可能发生的。
%因此，学者们提出了条件连通度的定义，其中一类著名的条件连通度是$g$- 限制连通度，它们要求去掉故障集合后每个顶点至少存在$g$个无故障的邻接点。
%当$g=0$时，$g$-限制连通度等同于传统的连通度，因此连通度可以看作是$g$-限制连通度的一种特殊情形，$g$-限制连通度则是连通度的一种推广。
%本文在$g$-限制连通度的基础上，提出了一种更具一般性且符合实际的条件连通度定义。
%
%我们发现，在某些实际网络中，故障的发生具有随机性，因此小范围内大量故障的概率较低。
%由此，我们可以大胆假设，距离较近的顶点，与它们相邻的故障顶点(边)较少。
%换言之，距离较近的两个顶点，它们的无故障邻接点的数量应该较多。
%因此在$g$-限制连通度的基础上，我们提出了一种与距离相关的条件连通度定义――$(g,d,k)$-条件连通度。
%$g$表示要求去掉故障集合后每个顶点至少存在$g$个无故障的邻接点，
%$d$表示顶点之间距离，$k$表示我们设定的参数。
%我们要求对于任意两个顶点$u$和$v$，如果它们之间的距离不超过$d$，那么$u$ 和$v$ 的度数之和不小于$2g+k$。
%具体的$(g,d,k)$-条件连通度定义以及相关术语的解释，请参见第二章和第三章。
%
%$(g,d,k)$-条件连通度可以看作是$g$-限制连通度的推广。当$k=0$时，$(g,D_{G},0)$-条件连通度和$g$-限制连通度在定义上是等价的。
%因此，$g$-限制连通度可以看作是$(g,d,k)$-条件连通度的一种特殊情形。
%$(g,d,k)$-条件连通度的提出为研究超立方体等网络的容错性提供了更具普遍意义的衡量指标。
%
%在本文中，基于新提出的条件连通度定义，我们研究得出了以下成果：
%
%1. 我们通过理论推导，给出了超立方体网络上某些特定$(g,d,k)$-条件(边)连通度的结果：
%\begin{align*}
%(1)& \kappa^{1,1,k}(Q_{n}) = \left\{ \begin{array}{l}
%        (k+2)n-2(k+1)+\binom{k+1}{2}  \makebox{ \; ，其中 $k\leq n-5$,} \\
%        n(n-1)/2  \makebox{ \; ，其中 $n-4\leq k \leq n-1$,}；
%    \end{array}\right. \nonumber
%    \label{eq:Cskip}\\
%(2)&\kappa^{1,d,2}(Q_{n})= 4n-8， \makebox{ \; ，其中$n \geq 4$ ，$d\geq 2$；}\\
%(3)&\lambda^{1,1,1}(Q_{n}) = 3n-4，\makebox{ \; ，其中$n \geq 4$；}\\
%(4)&\lambda^{1,d,2}(Q_{n}) = 4n-8，\makebox{ \; ，其中$n \geq 6 $，$1 \leq d \leq n$。}
%\end{align*}
%
%
%2. 在$(1,1,1)$-条件连通的情况下，我们提出了一种基于局部信息的容错单播路由算法，该算法通过构建长度不超过3的跨越路径来选择用于路由的维度。
%我们分析了该算法的时间复杂度和空间复杂度，并且与现有的几种单播路由算法从成功率，运行时间，路径长度等方面进行了比较。
%
%3. 本文结合$(g,d,k)$-条件边连通的定义，提出了一种新的条件容错哈密顿性质：$f$-$(g,d,k)$条件边容错哈密顿。
%本文证明，当$n\geq 4$时，$n$维超立方体是$(4n-13)$-$(3,0,0)$条件边容错哈密顿的，并且这一结果是最优的。
%\fi







